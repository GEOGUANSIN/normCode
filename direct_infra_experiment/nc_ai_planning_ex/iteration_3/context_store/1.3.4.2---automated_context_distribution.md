### Step 3.2: Automated Context Distribution

With a formalized plan, the system can now accurately distribute context. This process feeds two artifacts to an LLM guided by a specialized meta-prompt:

1.  The formalized **NormCode (`.nc`)** file from Phase 2.
2.  The **Initial Context Manifest (`.json`)** and its associated `context_store` directory from Phase 1.

The LLM's task is to act as a context-aware analyst. It parses the raw documents (e.g., `raw---prompt.txt`, `raw---system_context.json`) in the `context_store` and, for each inference in the `.nc` plan, creates new, tailored context files. These are saved back to the `context_store` with specific naming conventions:

-   `{flow_index}---{description}.txt`: For contexts specific to a single inference.
-   `shared---{description}.txt`: For contexts used by multiple inferences.

The primary outputs are these newly generated context files and the updated `3.2_context_manifest.json` that maps inferences to them.

---

### Example Walkthrough

To illustrate, consider a user registration plan.

**1. Inputs:**

-   **Formalized Plan (`.nc` snippet):**
    ```normcode
    1.output|:<:(::(register a new user))
    1.1.grouping| &across[{1},{2},{3}]
    1.2.object| {step 1: check existence}<:{1}>
    1.2.1.assigning| $::.<username exists>
    1.2.2.judgement| ::<username exists?>
    1.2.2.1.object| {user name}
    1.3.object| {step 2: report error}<:{2}>
    1.3.1.assigning| $::.{error}
    1.3.2.imperative| ::(report error)
    1.3.2.1.timing| @if(<username exists?>)
    1.4.object| {step 3: create account}<:{3}>
    1.4.1.assigning| $::.{new user account}
    1.4.2.imperative| ::(create new user account)
    1.4.2.1.timing| @if!(<username exists?>)
    ```

-   **Initial `context_store`:**
    ```
    context_store/
    ├── raw---prompt.txt
    └── raw---system_context.json
    ```

**2. LLM Analysis and Context Creation:**

The LLM processes each inference:

-   **For inference `1.1.1` (`::<username exists?>`):**
    -   It identifies the need for database details and the case-insensitivity requirement.
    -   It extracts "database type: PostgreSQL, user_table: 'users', username_column: 'username'" from `raw---system_context.json`.
    -   It extracts "username check should be case-insensitive" from `raw---prompt.txt`.
    -   It synthesizes this into a new file: `context_store/1.2.2---check_username_existence.txt`.

-   **Shared Context Identification:**
    -   The LLM notices that multiple steps will interact with the database.
    -   It creates a shared context file: `context_store/shared---database_connection.txt`, containing the PostgreSQL connection details. This avoids duplicating this information for every database-related step.

**3. Outputs:**

-   **Updated `context_store`:**
    ```
    context_store/
    ├── 1.2.2---check_username_existence.txt
    ├── raw---prompt.txt
    ├── raw---system_context.json
    └── shared---database_connection.txt
    ```

-   **Updated Context Manifest (`3.2_context_manifest.json` snippet):**
    ```json
    {
      "context_mapping": {
        "1.2.2.object| ::<username exists?>": [
          "./context_store/1.2.2---check_username_existence.txt",
          "./context_store/shared---database_connection.txt"
        ],
        // ... other mappings
      }
    }
    ```
