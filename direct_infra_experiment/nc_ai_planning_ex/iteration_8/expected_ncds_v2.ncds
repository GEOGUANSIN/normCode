/: ========================================
/: NormCode Formalization Process (v2)
/: ========================================
/:
/: GOAL: Convert .ncds plan text to formal .ncd format
/:
/: FORMALIZATION with INCREMENTAL SAVE:
/:   1. Parse .ncds into structured lines
/:   2. For each concept line:
/:      - Read current .ncd output
/:      - Formalize the line
/:      - Append to .ncd content
/:      - Write updated .ncd file
/:   3. Return completed .ncd file
/:
/: INPUT:  .ncds file (source plan)
/: OUTPUT: .ncd file (built line-by-line with checkpoints)
/:

:<:{.ncd file complete}
    <= return the completed .ncd output
    /: ROOT: The final result after all lines processed
    /: Each line was saved incrementally during the loop

    /: ========================================
    /: GROUND CONCEPTS (External Inputs)
    /: ========================================

    <- {.ncds file}
        /: Ground: source NCDS plan file to be formalized

    <- {.ncd output path}
        /: Ground: where to write the formalized .ncd file

    /: ========================================
    /: PHASE 1: PARSE
    /: ========================================

    <- [parsed lines]
        <= parse .ncds file into JSON list of lines
        /: Each line has: flow_index, content, depth, inference_marker, concept_type
        <- {.ncds file}

    <- [concept lines]
        <= filter out comment lines
        /: Only keep lines that are concepts (not /: comments)
        <- [parsed lines]

    /: ========================================
    /: PHASE 2: FOR EACH CONCEPT LINE - FORMALIZE AND SAVE
    /: ========================================
    /: This loop processes one line at a time
    /: After each line: read current file, append new line, write updated file
    /: This enables incremental progress and crash recovery

    <- {final .ncd file written}
        <= for each concept line in concept lines
        /: Loop processes lines sequentially, building the .ncd incrementally
            <= return .ncd file status after processing this line
            /: LOOP RETURN: Each iteration produces an updated file state

            /: ----------------------------------------
            /: STEP 2a: READ CURRENT .NCD STATE
            /: ----------------------------------------
            <- {current .ncd content}
                <= read current .ncd file if exists
                /: On first line this is empty, grows with each iteration
                <- {.ncd output path}

            /: ----------------------------------------
            /: STEP 2b: FORMALIZE THIS LINE
            /: ----------------------------------------
            <- {formalized line}
                <= select first valid formalization result
                /: Based on classified type, apply matching syntax
                /: Only one option produces a result (timing-gated)

                /: STEP 2b-i: Classify the concept type
                <- {concept type}
                    <= judge what type of concept this line is
                    /: Returns: {object}, [relation], <proposition>,
                    /:   imperative, judgement, assigning, grouping, timing, looping
                    <- {concept line}

                /: STEP 2b-ii: Check each type condition
                <- <is object type>
                    <= check if concept type equals object
                    <- {concept type}

                <- <is relation type>
                    <= check if concept type equals relation
                    <- {concept type}

                <- <is proposition type>
                    <= check if concept type equals proposition
                    <- {concept type}

                <- <is imperative type>
                    <= check if concept type equals imperative
                    <- {concept type}

                <- <is judgement type>
                    <= check if concept type equals judgement
                    <- {concept type}

                <- <is assigning type>
                    <= check if concept type equals assigning
                    <- {concept type}

                <- <is grouping type>
                    <= check if concept type equals grouping
                    <- {concept type}

                <- <is timing type>
                    <= check if concept type equals timing
                    <- {concept type}

                <- <is looping type>
                    <= check if concept type equals looping
                    <- {concept type}

                /: STEP 2b-iii: Apply matching formalization (timing-gated)
                <- {object formalized}
                    <= formalize according to {object} syntax
                        <= when condition holds
                        <* <is object type>
                    <- {concept line}

                <- {relation formalized}
                    <= formalize according to [relation] syntax
                        <= when condition holds
                        <* <is relation type>
                    <- {concept line}

                <- {proposition formalized}
                    <= formalize according to <proposition> syntax
                        <= when condition holds
                        <* <is proposition type>
                    <- {concept line}

                <- {imperative formalized}
                    <= formalize according to imperative syntax
                    /: Add annotation: | ?{sequence}: imperative
                        <= when condition holds
                        <* <is imperative type>
                    <- {concept line}

                <- {judgement formalized}
                    <= formalize according to judgement syntax
                    /: Add annotation: | ?{sequence}: judgement
                        <= when condition holds
                        <* <is judgement type>
                    <- {concept line}

                <- {assigning formalized}
                    <= formalize according to assigning syntax
                    /: Add annotation: | ?{sequence}: assigning
                        <= when condition holds
                        <* <is assigning type>
                    <- {concept line}

                <- {grouping formalized}
                    <= formalize according to grouping syntax
                    /: Add annotation: | ?{sequence}: grouping
                        <= when condition holds
                        <* <is grouping type>
                    <- {concept line}

                <- {timing formalized}
                    <= formalize according to timing syntax
                    /: Add annotation: | ?{sequence}: timing
                        <= when condition holds
                        <* <is timing type>
                    <- {concept line}

                <- {looping formalized}
                    <= formalize according to looping syntax
                    /: Add annotation: | ?{sequence}: looping
                        <= when condition holds
                        <* <is looping type>
                    <- {concept line}

            /: ----------------------------------------
            /: STEP 2c: APPEND TO CURRENT CONTENT
            /: ----------------------------------------
            <- {updated .ncd content}
                <= append formalized line to current content
                /: Adds the new line with proper newline separator
                <- {current .ncd content}
                <- {formalized line}

            /: ----------------------------------------
            /: STEP 2d: WRITE UPDATED FILE (CHECKPOINT)
            /: ----------------------------------------
            <- {.ncd file written}
                <= write updated .ncd to output path
                /: INCREMENTAL SAVE: Progress preserved after each line
                /: If execution stops here, we have partial but valid output
                <- {.ncd output path}
                <- {updated .ncd content}

        /: Loop inputs and context
        <- [concept lines]
        <* {concept line}
            /: Loop context: the current concept line being processed

/: ========================================
/: SUMMARY: Incremental Save Pattern
/: ========================================
/:
/: KEY DIFFERENCE FROM v1:
/:   v1: Formalize all lines in memory, serialize at end
/:   v2: For each line: read → formalize → append → write
/:
/: BENEFITS:
/:   - Crash recovery: partial output preserved
/:   - Visibility: watch .ncd grow line-by-line
/:   - Resume: can skip already-processed lines
/:   - Consistency: matches derivation.pf.ncd checkpoint pattern
/:
/: DATA FLOW PER ITERATION:
/:   {concept line} 
/:     → classify type
/:     → apply matching syntax (timing-gated)
/:     → {formalized line}
/:     → append to {current .ncd content}
/:     → {updated .ncd content}
/:     → write to file
/:     → next line


