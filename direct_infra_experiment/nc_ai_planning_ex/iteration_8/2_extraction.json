[
  "Formalize a NormCode Draft Straightforward (.ncds) file into a formal NormCode Draft (.ncd).\n\nINPUTS:\n- .ncds file (source plan to formalize)\n- .ncd output file path (where to write the formalized result)\n\nOUTPUTS:\n- .ncd file with flow indices, semantic types, sequence types, value bindings\n\nSTEP 1: PARSE\nUse the parser to convert the .ncds into a JSON list of lines.\nEach line has: flow_index, content, depth, inference_marker, concept_type.\nThe parser identifies comments vs concept lines.\nFilter out comment lines - only process concept lines.\n\nSTEP 2: FOR EACH CONCEPT LINE (with incremental save)\nFor each line that is a concept (not a comment):\n\n  2a. Read the current .ncd output file (empty on first line, growing with each line)\n  \n  2b. Judge what type of concept this line is:\n    - {object} → a thing, entity, data structure\n    - [relation] → a connection, mapping, relationship\n    - <proposition> → a truth value, condition, boolean\n    - ::() imperative → transforms/produces something\n    - ::<> judgement → evaluates/decides something\n    - $ assigning → variable binding operation\n    - & grouping → parallel operations\n    - @ timing → async/wait operations\n    - * looping → iteration operation\n\n  2c. Apply formalization based on type:\n    - If {object}: apply object syntax formatting\n    - If [relation]: apply relation syntax formatting\n    - If <proposition>: apply proposition syntax formatting\n    - If ::() imperative: apply imperative syntax and add | ?{sequence}: imperative\n    - If ::<> judgement: apply judgement syntax and add | ?{sequence}: judgement\n    - If $ assigning: apply assigning syntax and add | ?{sequence}: assigning\n    - If & grouping: apply grouping syntax and add | ?{sequence}: grouping\n    - If @ timing: apply timing syntax and add | ?{sequence}: timing\n    - If * looping: apply looping syntax and add | ?{sequence}: looping\n\n  2d. Append the formalized line to the current .ncd content\n  \n  2e. Write the updated .ncd content to the output file\n      (This saves progress after each line - enables resume and visibility)\n\nSTEP 3: RETURN\nThe final .ncd file is complete after all lines are processed.\nEach line was saved incrementally, so the file grew line-by-line.\n\nCHECKPOINTING BEHAVIOR:\n- After each concept line is formalized, the .ncd file is updated\n- If execution is interrupted, partial progress is preserved\n- On resume, can potentially skip already-processed lines by comparing line counts\n\n\n",
  "{'concepts': [{'name': '.ncds file', 'type': 'object', 'role': 'input', 'description': 'Source plan to be formalized', 'source_phrase': '.ncds file (source plan to formalize)'}, {'name': '.ncd output file path', 'type': 'object', 'role': 'input', 'description': 'Destination path for the formalized result', 'source_phrase': '.ncd output file path (where to write the formalized result)'}, {'name': '.ncd file', 'type': 'object', 'role': 'output', 'description': 'Final formalized file with flow indices, semantic types, sequence types, and value bindings', 'source_phrase': '.ncd file with flow indices, semantic types, sequence types, value bindings'}, {'name': 'JSON list of lines', 'type': 'collection', 'role': 'intermediate', 'description': 'Parsed representation of the .ncds file where each line has metadata', 'source_phrase': 'convert the .ncds into a JSON list of lines'}, {'name': 'concept lines', 'type': 'collection', 'role': 'intermediate', 'description': 'Filtered lines that represent concepts (excluding comments)', 'source_phrase': 'Filter out comment lines - only process concept lines'}, {'name': 'concept line', 'type': 'object', 'role': 'loop_variable', 'description': 'Current line being processed in the iteration over concept lines', 'source_phrase': 'For each line that is a concept'}, {'name': 'current .ncd content', 'type': 'object', 'role': 'intermediate', 'description': 'The growing content of the .ncd file during incremental processing', 'source_phrase': 'Read the current .ncd output file'}, {'name': 'concept type', 'type': 'object', 'role': 'intermediate', 'description': 'Classification of the line as object, relation, proposition, imperative, judgement, assigning, grouping, timing, or looping', 'source_phrase': 'Judge what type of concept this line is'}, {'name': 'formalized line', 'type': 'object', 'role': 'intermediate', 'description': 'The result of applying syntax formatting based on concept type', 'source_phrase': 'Apply formalization based on type'}, {'name': 'line is a concept', 'type': 'condition', 'role': 'condition', 'description': 'Boolean condition determining if a line should be processed (not a comment)', 'source_phrase': 'each line that is a concept (not a comment)'}, {'name': 'execution is interrupted', 'type': 'condition', 'role': 'condition', 'description': 'Condition indicating whether processing was stopped before completion', 'source_phrase': 'If execution is interrupted'}], 'summary': {'output_concept': '.ncd file', 'input_concepts': ['.ncds file', '.ncd output file path'], 'total_count': 11}}",
  "{'operations': [{'name': 'parse .ncds file into JSON list of lines', 'type': 'imperative', 'category': 'extraction', 'execution': 'script', 'source_phrase': 'Use the parser to convert the .ncds into a JSON list of lines', 'inputs_hint': ['.ncds file'], 'output_hint': 'JSON list of lines'}, {'name': 'filter out comment lines', 'type': 'imperative', 'category': 'extraction', 'execution': 'script', 'source_phrase': 'Filter out comment lines - only process concept lines', 'inputs_hint': ['JSON list of lines'], 'output_hint': 'concept lines'}, {'name': 'iterate over concept lines', 'type': 'imperative', 'category': 'iteration', 'execution': 'script', 'source_phrase': 'For each concept line', 'inputs_hint': ['concept lines'], 'output_hint': 'current concept line'}, {'name': 'read current .ncd output file', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'Read the current .ncd output file', 'inputs_hint': ['.ncd output file path'], 'output_hint': '.ncd content'}, {'name': 'judge concept type', 'type': 'judgement', 'category': 'evaluation', 'execution': 'llm', 'source_phrase': 'Judge what type of concept this line is', 'inputs_hint': ['concept line'], 'output_hint': 'concept type'}, {'name': 'apply object syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If {object}: apply object syntax formatting', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted object line'}, {'name': 'apply relation syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If [relation]: apply relation syntax formatting', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted relation line'}, {'name': 'apply proposition syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If <proposition>: apply proposition syntax formatting', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted proposition line'}, {'name': 'apply imperative syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If ::() imperative: apply imperative syntax', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted imperative line'}, {'name': 'apply judgement syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If ::<> judgement: apply judgement syntax', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted judgement line'}, {'name': 'apply assigning syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If $ assigning: apply assigning syntax', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted assigning line'}, {'name': 'apply grouping syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If & grouping: apply grouping syntax', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted grouping line'}, {'name': 'apply timing syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If @ timing: apply timing syntax', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted timing line'}, {'name': 'apply looping syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If * looping: apply looping syntax', 'inputs_hint': ['concept line', 'concept type'], 'output_hint': 'formatted looping line'}, {'name': 'append formalized line to .ncd content', 'type': 'imperative', 'category': 'aggregation', 'execution': 'script', 'source_phrase': 'Append the formalized line to the current .ncd content', 'inputs_hint': ['formatted line', '.ncd content'], 'output_hint': 'updated .ncd content'}, {'name': 'write updated .ncd content to output file', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'Write the updated .ncd content to the output file', 'inputs_hint': ['updated .ncd content', '.ncd output file path'], 'output_hint': '.ncd file'}, {'name': 'return final .ncd file', 'type': 'imperative', 'category': 'return', 'execution': 'script', 'source_phrase': 'RETURN', 'inputs_hint': ['.ncd file'], 'output_hint': 'final .ncd file'}], 'summary': {'imperative_count': 15, 'judgement_count': 1, 'llm_operations': 9, 'script_operations': 7}}",
  "{'dependencies': [{'from': 'parse .ncds file into JSON list of lines', 'to': 'JSON list of lines', 'type': 'produces', 'description': 'Parsing operation produces the JSON representation'}, {'from': 'JSON list of lines', 'to': 'filter out comment lines', 'type': 'needs', 'description': 'Filtering requires the parsed JSON lines as input'}, {'from': 'filter out comment lines', 'to': 'concept lines', 'type': 'produces', 'description': 'Filtering operation produces the collection of concept lines'}, {'from': 'concept lines', 'to': 'iterate over concept lines', 'type': 'needs', 'description': 'Iteration requires the filtered concept lines'}, {'from': 'iterate over concept lines', 'to': 'concept line', 'type': 'produces', 'description': 'Iteration produces each individual concept line for processing'}, {'from': 'concept line', 'to': 'judge concept type', 'type': 'needs', 'description': 'Judging type requires the current concept line'}, {'from': 'judge concept type', 'to': 'concept type', 'type': 'produces', 'description': 'Judgement operation determines the type of the concept'}, {'from': 'concept type', 'to': 'apply object syntax formatting', 'type': 'conditions', 'description': 'Object formatting is applied when concept type is object'}, {'from': 'concept type', 'to': 'apply relation syntax formatting', 'type': 'conditions', 'description': 'Relation formatting is applied when concept type is relation'}, {'from': 'concept type', 'to': 'apply proposition syntax formatting', 'type': 'conditions', 'description': 'Proposition formatting is applied when concept type is proposition'}, {'from': 'concept type', 'to': 'apply imperative syntax formatting', 'type': 'conditions', 'description': 'Imperative formatting is applied when concept type is imperative'}, {'from': 'concept type', 'to': 'apply judgement syntax formatting', 'type': 'conditions', 'description': 'Judgement formatting is applied when concept type is judgement'}, {'from': 'concept type', 'to': 'apply assigning syntax formatting', 'type': 'conditions', 'description': 'Assigning formatting is applied when concept type is assigning'}, {'from': 'concept type', 'to': 'apply grouping syntax formatting', 'type': 'conditions', 'description': 'Grouping formatting is applied when concept type is grouping'}, {'from': 'concept type', 'to': 'apply timing syntax formatting', 'type': 'conditions', 'description': 'Timing formatting is applied when concept type is timing'}, {'from': 'concept type', 'to': 'apply looping syntax formatting', 'type': 'conditions', 'description': 'Looping formatting is applied when concept type is looping'}, {'from': 'concept line', 'to': 'apply object syntax formatting', 'type': 'needs', 'description': 'Object formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply relation syntax formatting', 'type': 'needs', 'description': 'Relation formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply proposition syntax formatting', 'type': 'needs', 'description': 'Proposition formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply imperative syntax formatting', 'type': 'needs', 'description': 'Imperative formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply judgement syntax formatting', 'type': 'needs', 'description': 'Judgement formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply assigning syntax formatting', 'type': 'needs', 'description': 'Assigning formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply grouping syntax formatting', 'type': 'needs', 'description': 'Grouping formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply timing syntax formatting', 'type': 'needs', 'description': 'Timing formatting needs the concept line content'}, {'from': 'concept line', 'to': 'apply looping syntax formatting', 'type': 'needs', 'description': 'Looping formatting needs the concept line content'}, {'from': 'apply object syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Object formatting produces a formalized line'}, {'from': 'apply relation syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Relation formatting produces a formalized line'}, {'from': 'apply proposition syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Proposition formatting produces a formalized line'}, {'from': 'apply imperative syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Imperative formatting produces a formalized line'}, {'from': 'apply judgement syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Judgement formatting produces a formalized line'}, {'from': 'apply assigning syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Assigning formatting produces a formalized line'}, {'from': 'apply grouping syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Grouping formatting produces a formalized line'}, {'from': 'apply timing syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Timing formatting produces a formalized line'}, {'from': 'apply looping syntax formatting', 'to': 'formalized line', 'type': 'produces', 'description': 'Looping formatting produces a formalized line'}, {'from': '.ncd output file path', 'to': 'read current .ncd output file', 'type': 'needs', 'description': 'Reading the file requires the output path'}, {'from': 'read current .ncd output file', 'to': 'current .ncd content', 'type': 'produces', 'description': 'File reading produces the current content'}, {'from': 'current .ncd content', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending requires the current content'}, {'from': 'formalized line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending requires the newly formalized line'}, {'from': 'append formalized line to .ncd content', 'to': 'updated .ncd content', 'type': 'produces', 'description': 'Appending produces the updated content'}, {'from': 'updated .ncd content', 'to': 'write updated .ncd content to output file', 'type': 'needs', 'description': 'Writing requires the updated content'}, {'from': '.ncd output file path', 'to': 'write updated .ncd content to output file', 'type': 'needs', 'description': 'Writing requires the output file path'}, {'from': 'write updated .ncd content to output file', 'to': '.ncd file', 'type': 'produces', 'description': 'Writing operation produces the .ncd file (incrementally)'}, {'from': '.ncd file', 'to': 'return final .ncd file', 'type': 'needs', 'description': 'Returning requires the complete .ncd file'}, {'from': 'return final .ncd file', 'to': '.ncd file', 'type': 'produces', 'description': 'Return operation produces the final output'}, {'from': 'iterate over concept lines', 'to': 'read current .ncd output file', 'type': 'sequence', 'description': 'For each concept line, first read the current file before updating'}, {'from': 'read current .ncd output file', 'to': 'judge concept type', 'type': 'sequence', 'description': 'After reading current content, judge the type of the current concept line'}, {'from': 'judge concept type', 'to': 'apply object syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (object case)'}, {'from': 'judge concept type', 'to': 'apply relation syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (relation case)'}, {'from': 'judge concept type', 'to': 'apply proposition syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (proposition case)'}, {'from': 'judge concept type', 'to': 'apply imperative syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (imperative case)'}, {'from': 'judge concept type', 'to': 'apply judgement syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (judgement case)'}, {'from': 'judge concept type', 'to': 'apply assigning syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (assigning case)'}, {'from': 'judge concept type', 'to': 'apply grouping syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (grouping case)'}, {'from': 'judge concept type', 'to': 'apply timing syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (timing case)'}, {'from': 'judge concept type', 'to': 'apply looping syntax formatting', 'type': 'sequence', 'description': 'After judging type, apply the appropriate formatting (looping case)'}, {'from': 'apply object syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (object case)'}, {'from': 'apply relation syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (relation case)'}, {'from': 'apply proposition syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (proposition case)'}, {'from': 'apply imperative syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (imperative case)'}, {'from': 'apply judgement syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (judgement case)'}, {'from': 'apply assigning syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (assigning case)'}, {'from': 'apply grouping syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (grouping case)'}, {'from': 'apply timing syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (timing case)'}, {'from': 'apply looping syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'After formatting, append the line to content (looping case)'}, {'from': 'append formalized line to .ncd content', 'to': 'write updated .ncd content to output file', 'type': 'sequence', 'description': 'After appending, write the updated content to file'}, {'from': 'write updated .ncd content to output file', 'to': 'iterate over concept lines', 'type': 'sequence', 'description': 'After writing, continue to next concept line in iteration'}, {'from': 'execution is interrupted', 'to': 'write updated .ncd content to output file', 'type': 'conditions', 'description': 'The incremental save ensures progress is preserved if execution is interrupted'}], 'data_flow': [{'operation': 'parse .ncds file into JSON list of lines', 'inputs': ['.ncds file'], 'output': 'JSON list of lines'}, {'operation': 'filter out comment lines', 'inputs': ['JSON list of lines'], 'output': 'concept lines'}, {'operation': 'iterate over concept lines', 'inputs': ['concept lines'], 'output': 'concept line'}, {'operation': 'read current .ncd output file', 'inputs': ['.ncd output file path'], 'output': 'current .ncd content'}, {'operation': 'judge concept type', 'inputs': ['concept line'], 'output': 'concept type'}, {'operation': 'apply object syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply relation syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply proposition syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply imperative syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply judgement syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply assigning syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply grouping syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply timing syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'apply looping syntax formatting', 'inputs': ['concept line', 'concept type'], 'output': 'formalized line'}, {'operation': 'append formalized line to .ncd content', 'inputs': ['formalized line', 'current .ncd content'], 'output': 'updated .ncd content'}, {'operation': 'write updated .ncd content to output file', 'inputs': ['updated .ncd content', '.ncd output file path'], 'output': '.ncd file'}, {'operation': 'return final .ncd file', 'inputs': ['.ncd file'], 'output': '.ncd file'}], 'summary': {'root_output': '.ncd file', 'ground_inputs': ['.ncds file', '.ncd output file path'], 'execution_order': ['parse .ncds file into JSON list of lines', 'filter out comment lines', 'iterate over concept lines', 'read current .ncd output file', 'judge concept type', 'apply object syntax formatting', 'apply relation syntax formatting', 'apply proposition syntax formatting', 'apply imperative syntax formatting', 'apply judgement syntax formatting', 'apply assigning syntax formatting', 'apply grouping syntax formatting', 'apply timing syntax formatting', 'apply looping syntax formatting', 'append formalized line to .ncd content', 'write updated .ncd content to output file', 'return final .ncd file']}}",
  "{'patterns': [{'type': 'linear', 'trigger_phrase': 'Formalize a NormCode Draft Straightforward (.ncds) file into a formal NormCode Draft (.ncd)', 'elements': {'collection': None, 'current_item': None, 'condition': None, 'gated_operation': None, 'discriminator': None, 'options': None, 'items': None}}, {'type': 'iteration', 'trigger_phrase': 'FOR EACH CONCEPT LINE', 'elements': {'collection': 'concept lines', 'current_item': 'concept line', 'condition': None, 'gated_operation': None, 'discriminator': None, 'options': None, 'items': None}}, {'type': 'selection', 'trigger_phrase': 'Judge what type of concept this line is: - {object} → ... - [relation] → ...', 'elements': {'collection': None, 'current_item': None, 'condition': None, 'gated_operation': None, 'discriminator': 'concept_type', 'options': [{'condition': 'line is {object}', 'operation': 'apply object syntax formatting'}, {'condition': 'line is [relation]', 'operation': 'apply relation syntax formatting'}, {'condition': 'line is <proposition>', 'operation': 'apply proposition syntax formatting'}, {'condition': 'line is ::() imperative', 'operation': 'apply imperative syntax and add | ?{sequence}: imperative'}, {'condition': 'line is ::<> judgement', 'operation': 'apply judgement syntax and add | ?{sequence}: judgement'}, {'condition': 'line is $ assigning', 'operation': 'apply assigning syntax and add | ?{sequence}: assigning'}, {'condition': 'line is & grouping', 'operation': 'apply grouping syntax and add | ?{sequence}: grouping'}, {'condition': 'line is @ timing', 'operation': 'apply timing syntax and add | ?{sequence}: timing'}, {'condition': 'line is * looping', 'operation': 'apply looping syntax and add | ?{sequence}: looping'}], 'items': None}}], 'summary': {'has_iteration': True, 'has_conditional': False, 'has_selection': True, 'has_grouping': False, 'is_self_seeding': False, 'pattern_count': 3}}"
]