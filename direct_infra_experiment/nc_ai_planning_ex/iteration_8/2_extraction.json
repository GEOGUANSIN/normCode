[
  "{'refined_instruction': \"NormCode Draft Formalizer:\\n\\nINPUT:\\n- NormCode Draft Straightforward (.ncds) file containing concept lines and comments\\n\\nOUTPUT:\\n- Formal NormCode Draft (.ncd) file with fully formatted lines including flow indices, semantic types, sequence types, value bindings, and proper syntax annotations (e.g., | ?{sequence}:)\\n\\nPROCESS:\\n1. Parse the .ncds file into a JSON list of lines, where each line contains: flow_index, content, depth, inference_marker, and concept_type\\n2. Filter out comment lines; retain only concept lines for processing\\n3. For each concept line in the filtered list:\\n   a. Classify the concept type from the following categories: {object}, [relation], <proposition>, imperative, judgement, assigning, grouping, timing, looping\\n   b. Based on the classified type, apply the corresponding formal syntax rule:\\n      - If {object}: format as '{concept} | ?{sequence}:'\\n      - If [relation]: format as '[subject -> predicate -> object] | ?{sequence}:'\\n      - If <proposition>: format as '<proposition> | ?{sequence}:'\\n      - If imperative: format with action directive and binding\\n      - If judgement: include evaluation criteria and outcome\\n      - If assigning: bind value to variable with assignment syntax\\n      - If grouping: wrap related concepts using grouping delimiters\\n      - If timing: annotate with temporal constraints\\n      - If looping: include iteration bounds and conditions\\n   c. Generate the formally syntaxed version of the line with all required annotations\\n4. Collect all formally syntaxed lines in order\\n5. Serialize the collection into a single .ncd text file using the parser, preserving line sequence and structure\\n\\nINTERMEDIATE RESULTS:\\n- Parsed JSON representation of all lines with metadata\\n- Filtered list of non-comment concept lines\\n- Concept type classification for each line\\n- Individually formalized line content before serialization\\n\\nERROR HANDLING:\\n- If a line cannot be parsed, skip it and continue with the next line\\n- If a concept type cannot be determined, log a warning and omit the line from output\\n- No partial writes: only produce output file if all steps complete successfully\\n\\nTERMINATION:\\n- Process ends after all concept lines are formalized and serialized into the final .ncd file\", 'structure': {'goal': 'Generate a formal .ncd file from a .ncds source by applying syntax rules based on concept type', 'inputs': ['.ncds file', 'line metadata (flow_index, content, depth, inference_marker, concept_type)'], 'outputs': ['.ncd file', 'formatted concept lines with syntax annotations', 'flow-indexed sequence with value bindings'], 'iterations': [{'collection': 'filtered concept lines (non-comments)', 'per_item': 'one formally syntaxed line with type-specific formatting'}], 'conditions': [{'condition': 'line is a comment', 'if_true': 'exclude from processing', 'if_false': 'proceed to concept type classification'}, {'condition': 'concept type is {object}', 'if_true': \"apply object syntax: '{concept} | ?{sequence}:'\"}, {'condition': 'concept type is [relation]', 'if_true': \"apply relation syntax: '[subject -> predicate -> object] | ?{sequence}:'\"}, {'condition': 'concept type is <proposition>', 'if_true': \"apply proposition syntax: '<proposition> | ?{sequence}:'\"}, {'condition': 'concept type is unrecognized', 'if_true': 'log warning, skip line'}], 'steps': ['parse .ncds file into JSON lines with metadata', 'filter out comment lines', 'classify concept type for each remaining line', 'apply type-specific formal syntax transformation', 'collect all formalized lines', 'serialize into final .ncd text format']}, 'patterns_used': ['linear', 'multi-input', 'iteration', 'conditional', 'grouping']}",
  "{'concepts': [{'name': '.ncds file', 'type': 'object', 'role': 'input', 'description': 'Input file containing concept lines and comments in straightforward format', 'source_phrase': 'NormCode Draft Straightforward (.ncds) file'}, {'name': 'concept lines', 'type': 'collection', 'role': 'input', 'description': 'Lines in the .ncds file that contain concepts to be processed', 'source_phrase': 'concept lines'}, {'name': 'comments', 'type': 'collection', 'role': 'input', 'description': 'Comment lines in the .ncds file that will be filtered out', 'source_phrase': 'comments'}, {'name': 'line metadata', 'type': 'object', 'role': 'input', 'description': 'Metadata associated with each line including flow_index, content, depth, inference_marker, and concept_type', 'source_phrase': 'line metadata (flow_index, content, depth, inference_marker, concept_type)'}, {'name': 'parsed JSON representation', 'type': 'object', 'role': 'intermediate', 'description': 'JSON representation of all lines with metadata after parsing the .ncds file', 'source_phrase': 'Parsed JSON representation of all lines with metadata'}, {'name': 'filtered list of non-comment concept lines', 'type': 'collection', 'role': 'intermediate', 'description': 'List of concept lines remaining after filtering out comment lines', 'source_phrase': 'Filtered list of non-comment concept lines'}, {'name': 'concept line', 'type': 'object', 'role': 'loop_variable', 'description': 'Current concept line being processed in the iteration', 'source_phrase': 'For each concept line in the filtered list'}, {'name': 'concept type classification', 'type': 'object', 'role': 'intermediate', 'description': 'Classification of the concept type for each line (e.g., object, relation, proposition)', 'source_phrase': 'Classify the concept type'}, {'name': 'formally syntaxed line content', 'type': 'object', 'role': 'intermediate', 'description': 'Individually formalized line content with all required annotations before serialization', 'source_phrase': 'Individually formalized line content before serialization'}, {'name': 'formally syntaxed lines', 'type': 'collection', 'role': 'intermediate', 'description': 'Collection of all formally syntaxed lines ready for serialization', 'source_phrase': 'Collect all formally syntaxed lines in order'}, {'name': 'is comment', 'type': 'condition', 'role': 'condition', 'description': 'Whether a line is a comment that should be excluded from processing', 'source_phrase': 'If a line is a comment'}, {'name': 'concept type is {object}', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as an object', 'source_phrase': 'If {object}'}, {'name': 'concept type is [relation]', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as a relation', 'source_phrase': 'If [relation]'}, {'name': 'concept type is <proposition>', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as a proposition', 'source_phrase': 'If <proposition>'}, {'name': 'concept type is imperative', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as an imperative', 'source_phrase': 'If imperative'}, {'name': 'concept type is judgement', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as a judgement', 'source_phrase': 'If judgement'}, {'name': 'concept type is assigning', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as an assigning', 'source_phrase': 'If assigning'}, {'name': 'concept type is grouping', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as a grouping', 'source_phrase': 'If grouping'}, {'name': 'concept type is timing', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as a timing', 'source_phrase': 'If timing'}, {'name': 'concept type is looping', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type is classified as a looping', 'source_phrase': 'If looping'}, {'name': 'concept type is unrecognized', 'type': 'condition', 'role': 'condition', 'description': 'Whether the concept type cannot be determined or is invalid', 'source_phrase': 'If a concept type cannot be determined'}, {'name': '.ncd file', 'type': 'object', 'role': 'output', 'description': 'Final output file in formal NormCode Draft format with all syntax annotations', 'source_phrase': 'Formal NormCode Draft (.ncd) file'}], 'summary': {'output_concept': '.ncd file', 'input_concepts': ['.ncds file', 'concept lines', 'comments', 'line metadata'], 'total_count': 20}}",
  "{'operations': [{'name': 'parse .ncds file into JSON list of lines with metadata', 'type': 'imperative', 'category': 'extraction', 'execution': 'script', 'source_phrase': 'Parse the .ncds file into a JSON list of lines, where each line contains: flow_index, content, depth, inference_marker, and concept_type', 'inputs_hint': ['.ncds file'], 'output_hint': 'parsed JSON representation of lines'}, {'name': 'filter out comment lines', 'type': 'imperative', 'category': 'selection', 'execution': 'script', 'source_phrase': 'Filter out comment lines; retain only concept lines for processing', 'inputs_hint': ['parsed lines', 'line type'], 'output_hint': 'filtered list of concept lines'}, {'name': 'iterate over filtered concept lines', 'type': 'imperative', 'category': 'iteration', 'execution': 'script', 'source_phrase': 'For each concept line in the filtered list', 'inputs_hint': ['filtered concept lines'], 'output_hint': 'current concept line'}, {'name': 'classify concept type', 'type': 'imperative', 'category': 'analysis', 'execution': 'llm', 'source_phrase': 'Classify the concept type from the following categories: {object}, [relation], <proposition>, imperative, judgement, assigning, grouping, timing, looping', 'inputs_hint': ['concept line content'], 'output_hint': 'classified concept type'}, {'name': 'check if concept type is {object}', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If {object}', 'inputs_hint': ['classified concept type'], 'output_hint': 'is object type'}, {'name': 'apply object syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': \"format as '{concept} | ?{sequence}:'\", 'inputs_hint': ['concept line', 'is object type'], 'output_hint': 'formatted object line'}, {'name': 'check if concept type is [relation]', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If [relation]', 'inputs_hint': ['classified concept type'], 'output_hint': 'is relation type'}, {'name': 'apply relation syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': \"format as '[subject -> predicate -> object] | ?{sequence}:'\", 'inputs_hint': ['concept line', 'is relation type'], 'output_hint': 'formatted relation line'}, {'name': 'check if concept type is <proposition>', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If <proposition>', 'inputs_hint': ['classified concept type'], 'output_hint': 'is proposition type'}, {'name': 'apply proposition syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': \"format as '<proposition> | ?{sequence}:'\", 'inputs_hint': ['concept line', 'is proposition type'], 'output_hint': 'formatted proposition line'}, {'name': 'check if concept type is imperative', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If imperative', 'inputs_hint': ['classified concept type'], 'output_hint': 'is imperative type'}, {'name': 'apply imperative syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'format with action directive and binding', 'inputs_hint': ['concept line', 'is imperative type'], 'output_hint': 'formatted imperative line'}, {'name': 'check if concept type is judgement', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If judgement', 'inputs_hint': ['classified concept type'], 'output_hint': 'is judgement type'}, {'name': 'apply judgement syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'include evaluation criteria and outcome', 'inputs_hint': ['concept line', 'is judgement type'], 'output_hint': 'formatted judgement line'}, {'name': 'check if concept type is assigning', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If assigning', 'inputs_hint': ['classified concept type'], 'output_hint': 'is assigning type'}, {'name': 'apply assigning syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'bind value to variable with assignment syntax', 'inputs_hint': ['concept line', 'is assigning type'], 'output_hint': 'formatted assigning line'}, {'name': 'check if concept type is grouping', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If grouping', 'inputs_hint': ['classified concept type'], 'output_hint': 'is grouping type'}, {'name': 'apply grouping syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'wrap related concepts using grouping delimiters', 'inputs_hint': ['concept line', 'is grouping type'], 'output_hint': 'formatted grouping line'}, {'name': 'check if concept type is timing', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If timing', 'inputs_hint': ['classified concept type'], 'output_hint': 'is timing type'}, {'name': 'apply timing syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'annotate with temporal constraints', 'inputs_hint': ['concept line', 'is timing type'], 'output_hint': 'formatted timing line'}, {'name': 'check if concept type is looping', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If looping', 'inputs_hint': ['classified concept type'], 'output_hint': 'is looping type'}, {'name': 'apply looping syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'include iteration bounds and conditions', 'inputs_hint': ['concept line', 'is looping type'], 'output_hint': 'formatted looping line'}, {'name': 'generate formally syntaxed version of line', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'Generate the formally syntaxed version of the line with all required annotations', 'inputs_hint': ['classified concept type', 'applied syntax rule'], 'output_hint': 'fully formatted line'}, {'name': 'return formalized line for collection', 'type': 'imperative', 'category': 'return', 'execution': 'script', 'source_phrase': 'Generate the formally syntaxed version... (within loop)', 'inputs_hint': ['formatted line'], 'output_hint': 'formalized line to be collected'}, {'name': 'collect all formally syntaxed lines in order', 'type': 'imperative', 'category': 'aggregation', 'execution': 'script', 'source_phrase': 'Collect all formally syntaxed lines in order', 'inputs_hint': ['formalized lines'], 'output_hint': 'complete list of formalized lines'}, {'name': 'serialize collection into .ncd text file', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'Serialize the collection into a single .ncd text file using the parser, preserving line sequence and structure', 'inputs_hint': ['collected formalized lines'], 'output_hint': '.ncd file'}, {'name': 'check if line cannot be parsed', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If a line cannot be parsed', 'inputs_hint': ['parsing result'], 'output_hint': 'is parse error'}, {'name': 'skip unparsable line', 'type': 'imperative', 'category': 'iteration', 'execution': 'script', 'source_phrase': 'skip it and continue with the next line', 'inputs_hint': ['is parse error'], 'output_hint': 'continue processing'}, {'name': 'check if concept type cannot be determined', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'If a concept type cannot be determined', 'inputs_hint': ['classification result'], 'output_hint': 'is unknown type'}, {'name': 'log warning for undetermined concept type', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'log a warning and omit the line from output', 'inputs_hint': ['is unknown type'], 'output_hint': 'warning log entry'}, {'name': 'check if all steps completed successfully', 'type': 'judgement', 'category': 'evaluation', 'execution': 'script', 'source_phrase': 'No partial writes: only produce output file if all steps complete successfully', 'inputs_hint': ['processing status'], 'output_hint': 'can write output'}], 'summary': {'imperative_count': 20, 'judgement_count': 12, 'llm_operations': 11, 'script_operations': 21}}",
  "{'dependencies': [{'from': 'serialize collection into .ncd text file', 'to': '.ncd file', 'type': 'produces', 'description': 'Final serialization produces the output file'}, {'from': 'collect all formally syntaxed lines in order', 'to': 'serialize collection into .ncd text file', 'type': 'needs', 'description': 'Serialization requires all formatted lines'}, {'from': 'return formalized line for collection', 'to': 'collect all formally syntaxed lines in order', 'type': 'aggregates', 'description': 'Collection built from individual returns'}, {'from': 'generate formally syntaxed version of line', 'to': 'return formalized line for collection', 'type': 'needs', 'description': 'Must generate full syntax before returning'}, {'from': 'apply object syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Object formatting contributes to final syntax'}, {'from': 'apply relation syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Relation formatting contributes to final syntax'}, {'from': 'apply proposition syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Proposition formatting contributes to final syntax'}, {'from': 'apply imperative syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Imperative formatting contributes to final syntax'}, {'from': 'apply judgement syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Judgement formatting contributes to final syntax'}, {'from': 'apply assigning syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Assigning formatting contributes to final syntax'}, {'from': 'apply grouping syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Grouping formatting contributes to final syntax'}, {'from': 'apply timing syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Timing formatting contributes to final syntax'}, {'from': 'apply looping syntax formatting', 'to': 'generate formally syntaxed version of line', 'type': 'needs', 'description': 'Looping formatting contributes to final syntax'}, {'from': 'check if concept type is {object}', 'to': 'apply object syntax formatting', 'type': 'conditions', 'description': 'Apply object syntax only if type is object'}, {'from': 'classify concept type', 'to': 'check if concept type is {object}', 'type': 'needs', 'description': \"Must classify before checking if it's an object\"}, {'from': 'check if concept type is [relation]', 'to': 'apply relation syntax formatting', 'type': 'conditions', 'description': 'Apply relation syntax only if type is relation'}, {'from': 'classify concept type', 'to': 'check if concept type is [relation]', 'type': 'needs', 'description': \"Must classify before checking if it's a relation\"}, {'from': 'check if concept type is <proposition>', 'to': 'apply proposition syntax formatting', 'type': 'conditions', 'description': 'Apply proposition syntax only if type is proposition'}, {'from': 'classify concept type', 'to': 'check if concept type is <proposition>', 'type': 'needs', 'description': \"Must classify before checking if it's a proposition\"}, {'from': 'check if concept type is imperative', 'to': 'apply imperative syntax formatting', 'type': 'conditions', 'description': 'Apply imperative syntax only if type is imperative'}, {'from': 'classify concept type', 'to': 'check if concept type is imperative', 'type': 'needs', 'description': \"Must classify before checking if it's an imperative\"}, {'from': 'check if concept type is judgement', 'to': 'apply judgement syntax formatting', 'type': 'conditions', 'description': 'Apply judgement syntax only if type is judgement'}, {'from': 'classify concept type', 'to': 'check if concept type is judgement', 'type': 'needs', 'description': \"Must classify before checking if it's a judgement\"}, {'from': 'check if concept type is assigning', 'to': 'apply assigning syntax formatting', 'type': 'conditions', 'description': 'Apply assigning syntax only if type is assigning'}, {'from': 'classify concept type', 'to': 'check if concept type is assigning', 'type': 'needs', 'description': \"Must classify before checking if it's an assigning\"}, {'from': 'check if concept type is grouping', 'to': 'apply grouping syntax formatting', 'type': 'conditions', 'description': 'Apply grouping syntax only if type is grouping'}, {'from': 'classify concept type', 'to': 'check if concept type is grouping', 'type': 'needs', 'description': \"Must classify before checking if it's a grouping\"}, {'from': 'check if concept type is timing', 'to': 'apply timing syntax formatting', 'type': 'conditions', 'description': 'Apply timing syntax only if type is timing'}, {'from': 'classify concept type', 'to': 'check if concept type is timing', 'type': 'needs', 'description': \"Must classify before checking if it's a timing\"}, {'from': 'check if concept type is looping', 'to': 'apply looping syntax formatting', 'type': 'conditions', 'description': 'Apply looping syntax only if type is looping'}, {'from': 'classify concept type', 'to': 'check if concept type is looping', 'type': 'needs', 'description': \"Must classify before checking if it's a looping\"}, {'from': 'iterate over filtered concept lines', 'to': 'concept line', 'type': 'produces', 'description': 'Iteration provides the current line for processing'}, {'from': 'filtered list of non-comment concept lines', 'to': 'iterate over filtered concept lines', 'type': 'needs', 'description': 'Iteration requires the filtered list'}, {'from': 'filter out comment lines', 'to': 'filtered list of non-comment concept lines', 'type': 'produces', 'description': 'Filtering produces the processed list'}, {'from': 'parsed JSON representation', 'to': 'filter out comment lines', 'type': 'needs', 'description': 'Filtering requires parsed data'}, {'from': 'parse .ncds file into JSON list of lines with metadata', 'to': 'parsed JSON representation', 'type': 'produces', 'description': 'Parsing creates the JSON representation'}, {'from': '.ncds file', 'to': 'parse .ncds file into JSON list of lines with metadata', 'type': 'needs', 'description': 'Parsing requires the input file'}, {'from': 'classify concept type', 'to': 'concept type classification', 'type': 'produces', 'description': 'Classification operation determines the type'}, {'from': 'concept line', 'to': 'classify concept type', 'type': 'needs', 'description': 'Classification requires the current line content'}, {'from': 'check if line cannot be parsed', 'to': 'skip unparsable line', 'type': 'conditions', 'description': 'Skip line only if parsing failed'}, {'from': 'parse .ncds file into JSON list of lines with metadata', 'to': 'check if line cannot be parsed', 'type': 'needs', 'description': 'Must attempt parsing before knowing if it failed'}, {'from': 'check if concept type cannot be determined', 'to': 'log warning for undetermined concept type', 'type': 'conditions', 'description': 'Log warning only if type cannot be determined'}, {'from': 'classify concept type', 'to': 'check if concept type cannot be determined', 'type': 'needs', 'description': 'Must attempt classification before knowing if it failed'}, {'from': 'check if all steps completed successfully', 'to': 'serialize collection into .ncd text file', 'type': 'conditions', 'description': 'Only serialize if all steps succeeded'}], 'data_flow': [{'operation': 'parse .ncds file into JSON list of lines with metadata', 'inputs': ['.ncds file'], 'output': 'parsed JSON representation'}, {'operation': 'filter out comment lines', 'inputs': ['parsed JSON representation'], 'output': 'filtered list of non-comment concept lines'}, {'operation': 'iterate over filtered concept lines', 'inputs': ['filtered list of non-comment concept lines'], 'output': 'concept line'}, {'operation': 'classify concept type', 'inputs': ['concept line'], 'output': 'concept type classification'}, {'operation': 'check if concept type is {object}', 'inputs': ['concept type classification'], 'output': 'concept type is {object}'}, {'operation': 'apply object syntax formatting', 'inputs': ['concept line', 'concept type is {object}'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is [relation]', 'inputs': ['concept type classification'], 'output': 'concept type is [relation]'}, {'operation': 'apply relation syntax formatting', 'inputs': ['concept line', 'concept type is [relation]'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is <proposition>', 'inputs': ['concept type classification'], 'output': 'concept type is <proposition>'}, {'operation': 'apply proposition syntax formatting', 'inputs': ['concept line', 'concept type is <proposition>'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is imperative', 'inputs': ['concept type classification'], 'output': 'concept type is imperative'}, {'operation': 'apply imperative syntax formatting', 'inputs': ['concept line', 'concept type is imperative'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is judgement', 'inputs': ['concept type classification'], 'output': 'concept type is judgement'}, {'operation': 'apply judgement syntax formatting', 'inputs': ['concept line', 'concept type is judgement'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is assigning', 'inputs': ['concept type classification'], 'output': 'concept type is assigning'}, {'operation': 'apply assigning syntax formatting', 'inputs': ['concept line', 'concept type is assigning'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is grouping', 'inputs': ['concept type classification'], 'output': 'concept type is grouping'}, {'operation': 'apply grouping syntax formatting', 'inputs': ['concept line', 'concept type is grouping'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is timing', 'inputs': ['concept type classification'], 'output': 'concept type is timing'}, {'operation': 'apply timing syntax formatting', 'inputs': ['concept line', 'concept type is timing'], 'output': 'formally syntaxed line content'}, {'operation': 'check if concept type is looping', 'inputs': ['concept type classification'], 'output': 'concept type is looping'}, {'operation': 'apply looping syntax formatting', 'inputs': ['concept line', 'concept type is looping'], 'output': 'formally syntaxed line content'}, {'operation': 'generate formally syntaxed version of line', 'inputs': ['concept type classification', 'applied syntax rule'], 'output': 'formally syntaxed line content'}, {'operation': 'return formalized line for collection', 'inputs': ['formally syntaxed line content'], 'output': 'formally syntaxed lines'}, {'operation': 'collect all formally syntaxed lines in order', 'inputs': ['formally syntaxed lines'], 'output': 'collected formalized lines'}, {'operation': 'serialize collection into .ncd text file', 'inputs': ['collected formalized lines'], 'output': '.ncd file'}], 'summary': {'root_output': '.ncd file', 'ground_inputs': ['.ncds file'], 'execution_order': ['parse .ncds file into JSON list of lines with metadata', 'filter out comment lines', 'iterate over filtered concept lines', 'classify concept type', 'check if concept type is {object}', 'apply object syntax formatting', 'check if concept type is [relation]', 'apply relation syntax formatting', 'check if concept type is <proposition>', 'apply proposition syntax formatting', 'check if concept type is imperative', 'apply imperative syntax formatting', 'check if concept type is judgement', 'apply judgement syntax formatting', 'check if concept type is assigning', 'apply assigning syntax formatting', 'check if concept type is grouping', 'apply grouping syntax formatting', 'check if concept type is timing', 'apply timing syntax formatting', 'check if concept type is looping', 'apply looping syntax formatting', 'generate formally syntaxed version of line', 'return formalized line for collection', 'collect all formally syntaxed lines in order', 'serialize collection into .ncd text file']}}",
  "{'patterns': [{'type': 'iteration', 'trigger_phrase': 'For each concept line in the filtered list', 'elements': {'collection': 'filtered concept lines (non-comments)', 'current_item': 'concept line', 'condition': None, 'gated_operation': None, 'alternative': None, 'discriminator': None, 'options': None, 'items': None}}, {'type': 'selection', 'trigger_phrase': 'Based on the classified type, apply the corresponding formal syntax rule', 'elements': {'collection': None, 'current_item': None, 'condition': None, 'gated_operation': None, 'alternative': None, 'discriminator': 'concept type', 'options': [{'condition': 'concept type is {object}', 'operation': \"format as '{concept} | ?{sequence}:'\"}, {'condition': 'concept type is [relation]', 'operation': \"format as '[subject -> predicate -> object] | ?{sequence}:'\"}, {'condition': 'concept type is <proposition>', 'operation': \"format as '<proposition> | ?{sequence}:'\"}, {'condition': 'concept type is imperative', 'operation': 'format with action directive and binding'}, {'condition': 'concept type is judgement', 'operation': 'include evaluation criteria and outcome'}, {'condition': 'concept type is assigning', 'operation': 'bind value to variable with assignment syntax'}, {'condition': 'concept type is grouping', 'operation': 'wrap related concepts using grouping delimiters'}, {'condition': 'concept type is timing', 'operation': 'annotate with temporal constraints'}, {'condition': 'concept type is looping', 'operation': 'include iteration bounds and conditions'}], 'items': None}}, {'type': 'conditional', 'trigger_phrase': 'If a line cannot be parsed', 'elements': {'collection': None, 'current_item': None, 'condition': 'line cannot be parsed', 'gated_operation': 'skip it and continue with the next line', 'alternative': None, 'discriminator': None, 'options': None, 'items': None}}, {'type': 'conditional', 'trigger_phrase': 'If a concept type cannot be determined', 'elements': {'collection': None, 'current_item': None, 'condition': 'concept type cannot be determined', 'gated_operation': 'log a warning and omit the line from output', 'alternative': None, 'discriminator': None, 'options': None, 'items': None}}, {'type': 'conditional', 'trigger_phrase': 'line is a comment', 'elements': {'collection': None, 'current_item': None, 'condition': 'line is a comment', 'gated_operation': 'exclude from processing', 'alternative': 'proceed to concept type classification', 'discriminator': None, 'options': None, 'items': None}}, {'type': 'grouping', 'trigger_phrase': 'Collect all formally syntaxed lines', 'elements': {'collection': None, 'current_item': None, 'condition': None, 'gated_operation': None, 'alternative': None, 'discriminator': None, 'options': None, 'items': 'formally syntaxed lines'}}], 'summary': {'has_iteration': True, 'has_conditional': True, 'has_selection': True, 'has_grouping': True, 'is_self_seeding': False, 'pattern_count': 6}}"
]