[
  "Formalize a NormCode Draft Straightforward (.ncds) file into a formal NormCode Draft (.ncd).\n\nINPUTS:\n- .ncds file (source plan to formalize)\n- .ncd output file path (where to write the formalized result)\n\nOUTPUTS:\n- .ncd file with flow indices, semantic types, sequence types, value bindings\n\nSTEP 1: PARSE\nUse the parser to convert the .ncds into a JSON list of lines.\nEach line has: flow_index, content, depth, inference_marker, concept_type.\nThe parser identifies comments vs concept lines.\nFilter out comment lines - only process concept lines.\n\nSTEP 2: FOR EACH CONCEPT LINE (with incremental save)\nFor each line that is a concept (not a comment):\n\n  2a. Read the current .ncd output file (empty on first line, growing with each line)\n  \n  2b. Judge what type of concept this line is:\n    - {object} → a thing, entity, data structure\n    - [relation] → a connection, mapping, relationship\n    - <proposition> → a truth value, condition, boolean\n    - ::() imperative → transforms/produces something\n    - ::<> judgement → evaluates/decides something\n    - $ assigning → variable binding operation\n    - & grouping → parallel operations\n    - @ timing → async/wait operations\n    - * looping → iteration operation\n\n  2c. Apply formalization based on type:\n    - If {object}: apply object syntax formatting\n    - If [relation]: apply relation syntax formatting\n    - If <proposition>: apply proposition syntax formatting\n    - If ::() imperative: apply imperative syntax and add | ?{sequence}: imperative\n    - If ::<> judgement: apply judgement syntax and add | ?{sequence}: judgement\n    - If $ assigning: apply assigning syntax and add | ?{sequence}: assigning\n    - If & grouping: apply grouping syntax and add | ?{sequence}: grouping\n    - If @ timing: apply timing syntax and add | ?{sequence}: timing\n    - If * looping: apply looping syntax and add | ?{sequence}: looping\n\n  2d. Append the formalized line to the current .ncd content\n  \n  2e. Write the updated .ncd content to the output file\n      (This saves progress after each line - enables resume and visibility)\n\nSTEP 3: RETURN\nThe final .ncd file is complete after all lines are processed.\nEach line was saved incrementally, so the file grew line-by-line.\n\nCHECKPOINTING BEHAVIOR:\n- After each concept line is formalized, the .ncd file is updated\n- If execution is interrupted, partial progress is preserved\n- On resume, can potentially skip already-processed lines by comparing line counts\n\n\n",
  "{'concepts': [{'name': '.ncds file', 'type': 'object', 'role': 'input', 'description': 'Source plan in Draft Straightforward format to be formalized', 'source_phrase': '.ncds file (source plan to formalize)'}, {'name': '.ncd output file path', 'type': 'object', 'role': 'input', 'description': 'File system path where the formalized result will be written', 'source_phrase': '.ncd output file path (where to write the formalized result)'}, {'name': '.ncd file', 'type': 'object', 'role': 'output', 'description': 'Final formalized NormCode Draft file with full metadata and structure', 'source_phrase': 'OUTPUTS: - .ncd file with flow indices, semantic types, sequence types, value bindings'}, {'name': 'JSON list of lines', 'type': 'collection', 'role': 'intermediate', 'description': 'Parsed representation of the .ncds content as structured data', 'source_phrase': 'convert the .ncds into a JSON list of lines'}, {'name': 'line', 'type': 'object', 'role': 'loop_variable', 'description': 'Current line being processed in the iteration over concept lines', 'source_phrase': 'For each line that is a concept'}, {'name': 'concept line', 'type': 'collection', 'role': 'intermediate', 'description': 'Filtered set of lines identified as concepts (excluding comments)', 'source_phrase': 'Filter out comment lines - only process concept lines'}, {'name': 'comment line', 'type': 'object', 'role': 'intermediate', 'description': 'Line identified as a comment, excluded from processing', 'source_phrase': 'Filter out comment lines'}, {'name': 'current .ncd output file', 'type': 'object', 'role': 'intermediate', 'description': 'Partially constructed .ncd content read before processing each new line', 'source_phrase': 'Read the current .ncd output file'}, {'name': 'concept type', 'type': 'object', 'role': 'intermediate', 'description': 'Judged category of the current concept line (e.g., object, relation, imperative)', 'source_phrase': 'Judge what type of concept this line is'}, {'name': 'object', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line represents an object-type concept', 'source_phrase': '{object} → a thing, entity, data structure'}, {'name': 'relation', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line represents a relation-type concept', 'source_phrase': '[relation] → a connection, mapping, relationship'}, {'name': 'proposition', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line represents a proposition/condition', 'source_phrase': '<proposition> → a truth value, condition, boolean'}, {'name': 'imperative', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line is an imperative operation', 'source_phrase': '::() imperative → transforms/produces something'}, {'name': 'judgement', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line is a judgement operation', 'source_phrase': '::<> judgement → evaluates/decides something'}, {'name': 'assigning', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line is a variable assignment', 'source_phrase': '$ assigning → variable binding operation'}, {'name': 'grouping', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line involves parallel operations', 'source_phrase': '& grouping → parallel operations'}, {'name': 'timing', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line involves timing or async operations', 'source_phrase': '@ timing → async/wait operations'}, {'name': 'looping', 'type': 'condition', 'role': 'condition', 'description': 'Whether the current line involves iteration', 'source_phrase': '* looping → iteration operation'}, {'name': 'formalized line', 'type': 'object', 'role': 'intermediate', 'description': 'The result of applying formal syntax to a concept line', 'source_phrase': 'Append the formalized line to the current .ncd content'}, {'name': 'updated .ncd content', 'type': 'object', 'role': 'intermediate', 'description': 'The growing .ncd content after appending a new formalized line', 'source_phrase': 'Write the updated .ncd content to the output file'}, {'name': 'execution interrupted', 'type': 'condition', 'role': 'condition', 'description': 'Whether the process was stopped before completion', 'source_phrase': 'If execution is interrupted, partial progress is preserved'}, {'name': 'already-processed lines', 'type': 'collection', 'role': 'intermediate', 'description': 'Lines that have been successfully formalized in a previous run', 'source_phrase': 'On resume, can potentially skip already-processed lines by comparing line counts'}], 'summary': {'output_concept': '.ncd file', 'input_concepts': ['.ncds file', '.ncd output file path'], 'total_count': 18}}",
  "{'operations': [{'name': 'parse .ncds file into JSON list of lines', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'Use the parser to convert the .ncds into a JSON list of lines', 'inputs_hint': ['.ncds file'], 'output_hint': 'JSON list of lines'}, {'name': 'filter out comment lines', 'type': 'imperative', 'category': 'extraction', 'execution': 'script', 'source_phrase': 'Filter out comment lines - only process concept lines', 'inputs_hint': ['JSON list of lines'], 'output_hint': 'concept lines only'}, {'name': 'iterate over each concept line', 'type': 'imperative', 'category': 'iteration', 'execution': 'script', 'source_phrase': 'For each line that is a concept (not a comment)', 'inputs_hint': ['concept lines'], 'output_hint': 'current concept line'}, {'name': 'read current .ncd output file', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'Read the current .ncd output file', 'inputs_hint': ['.ncd output file path'], 'output_hint': 'current .ncd content'}, {'name': 'judge concept type based on syntax marker', 'type': 'judgement', 'category': 'evaluation', 'execution': 'llm', 'source_phrase': 'Judge what type of concept this line is', 'inputs_hint': ['concept line content'], 'output_hint': 'concept type'}, {'name': 'apply object syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If {object}: apply object syntax formatting', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted object line'}, {'name': 'apply relation syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If [relation]: apply relation syntax formatting', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted relation line'}, {'name': 'apply proposition syntax formatting', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If <proposition>: apply proposition syntax formatting', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted proposition line'}, {'name': 'apply imperative syntax and sequence tag', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If ::() imperative: apply imperative syntax and add | ?{sequence}: imperative', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted imperative line'}, {'name': 'apply judgement syntax and sequence tag', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If ::<> judgement: apply judgement syntax and add | ?{sequence}: judgement', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted judgement line'}, {'name': 'apply assigning syntax and sequence tag', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If $ assigning: apply assigning syntax and add | ?{sequence}: assigning', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted assigning line'}, {'name': 'apply grouping syntax and sequence tag', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If & grouping: apply grouping syntax and add | ?{sequence}: grouping', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted grouping line'}, {'name': 'apply timing syntax and sequence tag', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If @ timing: apply timing syntax and add | ?{sequence}: timing', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted timing line'}, {'name': 'apply looping syntax and sequence tag', 'type': 'imperative', 'category': 'generation', 'execution': 'llm', 'source_phrase': 'If * looping: apply looping syntax and add | ?{sequence}: looping', 'inputs_hint': ['line content', 'concept type'], 'output_hint': 'formatted looping line'}, {'name': 'append formalized line to .ncd content', 'type': 'imperative', 'category': 'aggregation', 'execution': 'script', 'source_phrase': 'Append the formalized line to the current .ncd content', 'inputs_hint': ['current .ncd content', 'formatted line'], 'output_hint': 'updated .ncd content'}, {'name': 'write updated .ncd content to output file', 'type': 'imperative', 'category': 'file_io', 'execution': 'script', 'source_phrase': 'Write the updated .ncd content to the output file', 'inputs_hint': ['updated .ncd content', '.ncd output file path'], 'output_hint': '.ncd file'}], 'summary': {'imperative_count': 14, 'judgement_count': 1, 'llm_operations': 9, 'script_operations': 6}}",
  "{'dependencies': [{'from': 'parse .ncds file into JSON list of lines', 'to': 'JSON list of lines', 'type': 'produces', 'description': 'Parsing operation creates the structured representation'}, {'from': '.ncds file', 'to': 'parse .ncds file into JSON list of lines', 'type': 'needs', 'description': 'Parser requires the source .ncds file as input'}, {'from': 'filter out comment lines', 'to': 'concept lines only', 'type': 'produces', 'description': 'Filtering operation produces the collection of concept lines'}, {'from': 'JSON list of lines', 'to': 'filter out comment lines', 'type': 'needs', 'description': 'Filtering requires the parsed list of lines'}, {'from': 'iterate over each concept line', 'to': 'current concept line', 'type': 'produces', 'description': 'Iteration provides each concept line for processing'}, {'from': 'concept lines only', 'to': 'iterate over each concept line', 'type': 'needs', 'description': 'Iteration requires the filtered concept lines'}, {'from': 'read current .ncd output file', 'to': 'current .ncd content', 'type': 'produces', 'description': 'File read operation produces the current state'}, {'from': '.ncd output file path', 'to': 'read current .ncd output file', 'type': 'needs', 'description': 'Reading requires the output file path'}, {'from': 'judge concept type based on syntax marker', 'to': 'concept type', 'type': 'produces', 'description': 'Judgment operation determines the type of concept'}, {'from': 'current concept line', 'to': 'judge concept type based on syntax marker', 'type': 'needs', 'description': 'Type judgment requires examining the current line'}, {'from': 'concept type', 'to': 'object', 'type': 'discriminates', 'description': \"The judged concept type determines if it's an object\"}, {'from': 'concept type', 'to': 'relation', 'type': 'discriminates', 'description': \"The judged concept type determines if it's a relation\"}, {'from': 'concept type', 'to': 'proposition', 'type': 'discriminates', 'description': \"The judged concept type determines if it's a proposition\"}, {'from': 'concept type', 'to': 'imperative', 'type': 'discriminates', 'description': \"The judged concept type determines if it's imperative\"}, {'from': 'concept type', 'to': 'judgement', 'type': 'discriminates', 'description': \"The judged concept type determines if it's a judgement\"}, {'from': 'concept type', 'to': 'assigning', 'type': 'discriminates', 'description': \"The judged concept type determines if it's assigning\"}, {'from': 'concept type', 'to': 'grouping', 'type': 'discriminates', 'description': \"The judged concept type determines if it's grouping\"}, {'from': 'concept type', 'to': 'timing', 'type': 'discriminates', 'description': \"The judged concept type determines if it's timing\"}, {'from': 'concept type', 'to': 'looping', 'type': 'discriminates', 'description': \"The judged concept type determines if it's looping\"}, {'from': 'object', 'to': 'apply object syntax formatting', 'type': 'conditions', 'description': 'Object formatting is only applied when type is object'}, {'from': 'relation', 'to': 'apply relation syntax formatting', 'type': 'conditions', 'description': 'Relation formatting is only applied when type is relation'}, {'from': 'proposition', 'to': 'apply proposition syntax formatting', 'type': 'conditions', 'description': 'Proposition formatting is only applied when type is proposition'}, {'from': 'imperative', 'to': 'apply imperative syntax and sequence tag', 'type': 'conditions', 'description': 'Imperative formatting is only applied when type is imperative'}, {'from': 'judgement', 'to': 'apply judgement syntax and sequence tag', 'type': 'conditions', 'description': 'Judgement formatting is only applied when type is judgement'}, {'from': 'assigning', 'to': 'apply assigning syntax and sequence tag', 'type': 'conditions', 'description': 'Assigning formatting is only applied when type is assigning'}, {'from': 'grouping', 'to': 'apply grouping syntax and sequence tag', 'type': 'conditions', 'description': 'Grouping formatting is only applied when type is grouping'}, {'from': 'timing', 'to': 'apply timing syntax and sequence tag', 'type': 'conditions', 'description': 'Timing formatting is only applied when type is timing'}, {'from': 'looping', 'to': 'apply looping syntax and sequence tag', 'type': 'conditions', 'description': 'Looping formatting is only applied when type is looping'}, {'from': 'apply object syntax formatting', 'to': 'formatted object line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted object line'}, {'from': 'apply relation syntax formatting', 'to': 'formatted relation line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted relation line'}, {'from': 'apply proposition syntax formatting', 'to': 'formatted proposition line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted proposition line'}, {'from': 'apply imperative syntax and sequence tag', 'to': 'formatted imperative line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted imperative line'}, {'from': 'apply judgement syntax and sequence tag', 'to': 'formatted judgement line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted judgement line'}, {'from': 'apply assigning syntax and sequence tag', 'to': 'formatted assigning line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted assigning line'}, {'from': 'apply grouping syntax and sequence tag', 'to': 'formatted grouping line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted grouping line'}, {'from': 'apply timing syntax and sequence tag', 'to': 'formatted timing line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted timing line'}, {'from': 'apply looping syntax and sequence tag', 'to': 'formatted looping line', 'type': 'produces', 'description': 'Formatting operation produces properly formatted looping line'}, {'from': 'append formalized line to .ncd content', 'to': 'updated .ncd content', 'type': 'produces', 'description': 'Append operation combines existing content with new line'}, {'from': 'current .ncd content', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending requires the current content'}, {'from': 'formatted object line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted relation line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted proposition line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted imperative line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted judgement line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted assigning line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted grouping line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted timing line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'formatted looping line', 'to': 'append formalized line to .ncd content', 'type': 'needs', 'description': 'Appending needs the newly formatted line'}, {'from': 'write updated .ncd content to output file', 'to': '.ncd file', 'type': 'produces', 'description': 'Write operation produces the final .ncd file'}, {'from': 'updated .ncd content', 'to': 'write updated .ncd content to output file', 'type': 'needs', 'description': 'Writing requires the updated content'}, {'from': '.ncd output file path', 'to': 'write updated .ncd content to output file', 'type': 'needs', 'description': 'Writing requires the output file path'}, {'from': 'write updated .ncd content to output file', 'to': 'execution interrupted', 'type': 'sequence', 'description': 'Writing occurs before checking interruption status'}, {'from': 'iterate over each concept line', 'to': 'read current .ncd output file', 'type': 'sequence', 'description': 'For each line, first read current state before processing'}, {'from': 'read current .ncd output file', 'to': 'judge concept type based on syntax marker', 'type': 'sequence', 'description': 'After reading, judge the type of the current line'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply object syntax formatting', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply relation syntax formatting', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply proposition syntax formatting', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply imperative syntax and sequence tag', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply judgement syntax and sequence tag', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply assigning syntax and sequence tag', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply grouping syntax and sequence tag', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply timing syntax and sequence tag', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'judge concept type based on syntax marker', 'to': 'apply looping syntax and sequence tag', 'type': 'sequence', 'description': 'Type judgment must precede formatting application'}, {'from': 'apply object syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply relation syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply proposition syntax formatting', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply imperative syntax and sequence tag', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply judgement syntax and sequence tag', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply assigning syntax and sequence tag', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply grouping syntax and sequence tag', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply timing syntax and sequence tag', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'apply looping syntax and sequence tag', 'to': 'append formalized line to .ncd content', 'type': 'sequence', 'description': 'Formatting must complete before appending'}, {'from': 'append formalized line to .ncd content', 'to': 'write updated .ncd content to output file', 'type': 'sequence', 'description': 'Content must be updated before writing'}], 'data_flow': [{'operation': 'parse .ncds file into JSON list of lines', 'inputs': ['.ncds file'], 'output': 'JSON list of lines'}, {'operation': 'filter out comment lines', 'inputs': ['JSON list of lines'], 'output': 'concept lines only'}, {'operation': 'iterate over each concept line', 'inputs': ['concept lines only'], 'output': 'current concept line'}, {'operation': 'read current .ncd output file', 'inputs': ['.ncd output file path'], 'output': 'current .ncd content'}, {'operation': 'judge concept type based on syntax marker', 'inputs': ['current concept line'], 'output': 'concept type'}, {'operation': 'apply object syntax formatting', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted object line'}, {'operation': 'apply relation syntax formatting', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted relation line'}, {'operation': 'apply proposition syntax formatting', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted proposition line'}, {'operation': 'apply imperative syntax and sequence tag', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted imperative line'}, {'operation': 'apply judgement syntax and sequence tag', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted judgement line'}, {'operation': 'apply assigning syntax and sequence tag', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted assigning line'}, {'operation': 'apply grouping syntax and sequence tag', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted grouping line'}, {'operation': 'apply timing syntax and sequence tag', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted timing line'}, {'operation': 'apply looping syntax and sequence tag', 'inputs': ['current concept line', 'concept type'], 'output': 'formatted looping line'}, {'operation': 'append formalized line to .ncd content', 'inputs': ['current .ncd content', 'formatted object line', 'formatted relation line', 'formatted proposition line', 'formatted imperative line', 'formatted judgement line', 'formatted assigning line', 'formatted grouping line', 'formatted timing line', 'formatted looping line'], 'output': 'updated .ncd content'}, {'operation': 'write updated .ncd content to output file', 'inputs': ['updated .ncd content', '.ncd output file path'], 'output': '.ncd file'}], 'summary': {'root_output': '.ncd file', 'ground_inputs': ['.ncds file', '.ncd output file path'], 'execution_order': ['parse .ncds file into JSON list of lines', 'filter out comment lines', 'iterate over each concept line', 'read current .ncd output file', 'judge concept type based on syntax marker', 'apply object syntax formatting', 'apply relation syntax formatting', 'apply proposition syntax formatting', 'apply imperative syntax and sequence tag', 'apply judgement syntax and sequence tag', 'apply assigning syntax and sequence tag', 'apply grouping syntax and sequence tag', 'apply timing syntax and sequence tag', 'apply looping syntax and sequence tag', 'append formalized line to .ncd content', 'write updated .ncd content to output file']}}",
  "{'patterns': [{'type': 'iteration', 'trigger_phrase': 'FOR EACH CONCEPT LINE', 'elements': {'collection': 'concept lines', 'current_item': 'concept line', 'condition': None, 'gated_operation': None, 'discriminator': None, 'options': None, 'items': None}}, {'type': 'selection', 'trigger_phrase': 'Judge what type of concept this line is', 'elements': {'collection': None, 'current_item': None, 'condition': None, 'gated_operation': None, 'discriminator': 'concept_type', 'options': [{'condition': 'line is {object}', 'operation': 'apply object syntax formatting'}, {'condition': 'line is [relation]', 'operation': 'apply relation syntax formatting'}, {'condition': 'line is <proposition>', 'operation': 'apply proposition syntax formatting'}, {'condition': 'line is ::() imperative', 'operation': 'apply imperative syntax and add | ?{sequence}: imperative'}, {'condition': 'line is ::<> judgement', 'operation': 'apply judgement syntax and add | ?{sequence}: judgement'}, {'condition': 'line is $ assigning', 'operation': 'apply assigning syntax and add | ?{sequence}: assigning'}, {'condition': 'line is & grouping', 'operation': 'apply grouping syntax and add | ?{sequence}: grouping'}, {'condition': 'line is @ timing', 'operation': 'apply timing syntax and add | ?{sequence}: timing'}, {'condition': 'line is * looping', 'operation': 'apply looping syntax and add | ?{sequence}: looping'}], 'items': None}}], 'summary': {'has_iteration': True, 'has_conditional': False, 'has_selection': True, 'has_grouping': False, 'is_self_seeding': False, 'pattern_count': 2}}"
]