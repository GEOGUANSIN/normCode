/: ========================================
/: File-Based Derivation Algorithm (Formal .ncd)
/: ========================================
/: 
/: GOAL: Transform natural language instruction into .ncds file
/: 
/: DERIVATION (per documentation) means:
/:   1. Extract concepts (nouns/data), operations (verbs/actions), dependencies
/:   2. Build hierarchical structure (dependency tree)
/:   3. Output as .ncds format
/:
/: This plan adds CHECKPOINTING for resumability:
/:   - Each phase writes results to file
/:   - On resume, completed phases load from cache
/:
/: INPUT:  instruction.txt (natural language)
/: OUTPUT: ncds_output.ncds (structured plan)
/:
/: CUE FILES LEGEND:
/:   %{cue_files} lists documentation that should be included as context
/:   when writing prompts for semantic (LLM) operations
/:
/: FORMAL SYNTAX KEY:
/:   :<: = output marker (final result)
/:   $. %>() = selection (pick first available)
/:   &[{}] %>[] = grouping (bundle into object)
/:   *. %>() = iteration (for each)
/:   @:'() = timing gate (if TRUE)
/:   @:!() = timing gate (if NOT true)
/:   ::() = imperative operation
/:   ::<{}>< > = judgement operation
/:   <:{N}> = value order marker
/:

:<:{ncds}
    <= ::(return ncds output written)
        /: ROOT: Return the final ncds result
        /: The real work happens in the dependency tree below
    <- {ncds output written}

    /: ========================================
    /: GROUND CONCEPTS (External Inputs)
    /: ========================================

    <- {instruction file path}
        /: Ground: Where to read the natural language instruction from

    <- {refinement questions file path}
        /: Ground: 7 questions to clarify vague instructions (from derivation_v2.md)

    <- {progress file path}
        /: Ground: Tracks which phases completed (enables resume)

    <- {refined instruction file path}
        /: Ground: Phase 1 checkpoint - stores refined/original instruction

    <- {extraction file path}
        /: Ground: Phase 2 checkpoint - stores extracted concepts/operations/deps

    <- {classifications file path}
        /: Ground: Phase 3 checkpoint - stores pattern types per operation

    <- {tree file path}
        /: Ground: Phase 4 checkpoint - stores the dependency tree structure

    <- {output file path}
        /: Ground: Final output - the .ncds file we're creating

    /: ========================================
    /: PHASE 0: READ RAW INPUT
    /: ========================================

    <- {raw instruction content}
        <= ::(read instruction from input file)
            /: FILE I/O: Load the natural language instruction
            /: This is the starting point - what the user wants to derive
        <- {instruction file path}

    /: ========================================
    /: PHASE 1: REFINEMENT
    /: ========================================
    /: PURPOSE: Ensure instruction is concrete enough for extraction
    /: 
    /: Per derivation.md: "Natural language is ambiguous and unstructured"
    /: Vague instructions like "analyze the data" can't be derived properly.
    /: We either clarify them OR pass through if already concrete.

    <- {refined instruction file written}
        <= ::(write refined instruction to checkpoint file)
            /: FILE I/O: Save refined instruction for Phase 2 to read
            /: Checkpoint enables resume - if we crash after this, Phase 2 can still run
        <- {refined instruction file path}<:{1}>
        <- {instruction to be written}<:{2}>
            <= $. %>({instruction to be written})
                /: SELECTION: Pick cache if available, else compute fresh
                /: Pattern: [check, cache_if_done, compute_if_not_done]

            <- <phase 1 already complete>
                <= ::<{check if phase 1 already complete in progress}><ALL True>
                    /: RESUME CHECK: Did we already finish Phase 1 in a previous run?
                <- {current progress}
                    <= ::(read progress from file if exists)
                        /: FILE I/O: Load progress tracker (may be empty/missing on first run)
                    <- {progress file path}

            <- {cached refined instruction}
                <= ::(read refined instruction from checkpoint)
                    /: CACHE PATH: If Phase 1 done, just load the saved result
                    /: Saves LLM calls on resume
                    <= @:'(<phase 1 already complete>)
                        /: TIMING GATE: Only execute if phase already complete
                    <* <phase 1 already complete>
                <- {refined instruction file path}

            <- {freshly refined instruction}
                <= $. %>({freshly refined instruction})
                    /: COMPUTATION PATH: Actually do the refinement work
                    /: This is a SELECTION between two options based on vagueness
                    <= @:!(<phase 1 already complete>)
                        /: TIMING GATE: Only execute if phase NOT complete
                    <* <phase 1 already complete>

                <- <instruction is vague>
                    <= ::<{judge if instruction lacks concrete details}><ALL True>
                        /: LLM JUDGEMENT: Is this instruction too vague to derive?
                        /: Examples of vague: "process the data", "analyze this"
                        /: Examples of concrete: "extract all nouns, then identify dependencies"
                        /: 
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#before-derivation-instruction-refinement",
                        /:   "documentation/current/4_compilation/derivation.md#the-derivation-problem"
                        /: ]
                        /: CONTEXT NEEDED: What makes an instruction "vague" vs "concrete"?
                        /:   - Vague: implicit loops, unnamed data, unclear conditions
                        /:   - Concrete: explicit loops, named entities, concrete operations
                    <- {raw instruction content}

                <- {original version}
                    <= ::(pass through raw instruction)
                        /: PASSTHROUGH: If instruction is already concrete, use as-is
                        /: No LLM call needed - just forward the value
                        <= @:!(<instruction is vague>)
                            /: TIMING GATE: Only if NOT vague
                        <* <instruction is vague>
                    <- {raw instruction content}

                <- {refined version}
                    <= ::(synthesize from refinement answers)
                        /: LLM SYNTHESIS: Combine Q&A answers into a concrete instruction
                        /: Takes the 7 refinement questions' answers and produces clear instruction
                        /:
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#the-refinement-process",
                        /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#rules-of-thumb-for-paraphrasing"
                        /: ]
                        /: CONTEXT NEEDED: How to synthesize a refined instruction
                        /:   - Make implicit loops explicit
                        /:   - Name all data entities
                        /:   - Make conditions concrete
                        /:   - Decompose compound operations
                        <= @:'(<instruction is vague>)
                            /: TIMING GATE: Only if vague
                        <* <instruction is vague>
                    <- {refinement answers}
                        <= ::(apply each refinement question)
                            /: LLM ITERATION: Ask each of 7 questions about the instruction
                            /:
                            /: %{cue_files}: [
                            /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#the-refinement-questions"
                            /: ]
                            /: CONTEXT NEEDED: The 7 refinement questions
                            /:   1. "What's the final output?"
                            /:   2. "What data exists at the start?"
                            /:   3. "Does this repeat?"
                            /:   4. "What triggers each step?"
                            /:   5. "When does it end?"
                            /:   6. "What conditions affect behavior?"
                            /:   7. "What's one atomic step?"
                        <- {raw instruction content}<:{1}>
                        <- {refinement questions content}<:{2}>
                            <= ::(read refinement questions from file)
                                /: FILE I/O: Load the 7 standard refinement questions
                            <- {refinement questions file path}

    <- {phase 1 complete}
        <= ::(write phase 1 status to progress file)
            /: CHECKPOINT: Mark Phase 1 done in progress tracker
            /: Enables resume from Phase 2 on next run
        <- {progress file path}<:{1}>
        <- {refined instruction file written}<:{2}>

    /: ========================================
    /: PHASE 2: EXTRACTION
    /: ========================================
    /: PURPOSE: Decompose instruction into raw materials for tree building
    /: 
    /: Per derivation.md Step 1-3:
    /:   - Identify Concepts: "Extract all data entities mentioned"
    /:   - Identify Operations: "Extract all actions/operations mentioned"  
    /:   - Determine Dependencies: "Figure out which concepts feed into which operations"
    /:
    /: This is the CORE of derivation - understanding WHAT is in the instruction

    <- {extraction file written}
        <= ::(write extraction results to checkpoint file)
            /: FILE I/O: Save extractions for Phase 3 and 4 to read
        <- {extraction file path}<:{1}>
        <- {extraction to be written}<:{2}>
            <= $. %>({extraction to be written})
                /: SELECTION: Cache or compute pattern (same as Phase 1)

            <- <phase 2 already complete>
                <= ::<{check if phase 2 already complete in progress}><ALL True>
                    /: RESUME CHECK
                <- {current progress}
                    <= ::(read progress from file if exists)
                    <- {progress file path}

            <- {cached extraction data}
                <= ::(read extraction from checkpoint)
                    /: CACHE PATH
                    <= @:'(<phase 2 already complete>)
                    <* <phase 2 already complete>
                <- {extraction file path}

            <- {freshly extracted data}
                <= &[{}] %>[{extracted concepts}, [extracted operations], [extracted dependencies], [extracted control patterns]] %+(extraction)
                    /: GROUPING: Combine 4 extraction results into one structured object
                    /: Output: {concepts: [...], operations: [...], dependencies: [...], patterns: [...]}
                    <= @:!(<phase 2 already complete>)
                    <* <phase 2 already complete>

                <- {refined instruction content}
                    <= ::(read refined instruction file from path)
                        /: FILE I/O: Load Phase 1 output (the concrete instruction)
                    <- {refined instruction file path}

                <- {extracted concepts}
                    <= ::(identify all nouns and data entities)
                        /: LLM EXTRACTION: Find all DATA mentioned in instruction
                        /:
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/derivation.md#step-1-identify-concepts",
                        /:   "documentation/current/2_grammar/semantic_concepts.md#object",
                        /:   "documentation/current/2_grammar/semantic_concepts.md#relation"
                        /: ]
                        /: CONTEXT NEEDED: What counts as a concept?
                        /:   - Object {}: Nouns, singular entities ("the sum", "user input")
                        /:   - Relation []: Plurals, collections ("the files", "all numbers")
                        /:   - Look for: "the X", "a Y", "all Z", input/output mentions
                    <- {refined instruction content}

                <- [extracted operations]
                    <= ::(identify all verbs and actions)
                        /: LLM EXTRACTION: Find all ACTIONS mentioned in instruction
                        /:
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/derivation.md#step-2-identify-operations",
                        /:   "documentation/current/2_grammar/semantic_concepts.md#imperative",
                        /:   "documentation/current/2_grammar/semantic_concepts.md#judgement"
                        /: ]
                        /: CONTEXT NEEDED: What counts as an operation?
                        /:   - Imperative ({}): Active verbs ("calculate", "extract", "generate")
                        /:   - Judgement <{}>: Questions, checks ("is X valid?", "check if Y")
                        /:   - Look for: action phrases, imperatives, "do X", "compute Y"
                    <- {refined instruction content}

                <- [extracted dependencies]
                    <= ::(identify what needs what)
                        /: LLM EXTRACTION: Find DATA FLOW between concepts/operations
                        /:
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/derivation.md#step-3-determine-dependencies",
                        /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#the-derivation-question"
                        /: ]
                        /: CONTEXT NEEDED: How to identify dependencies?
                        /:   - Temporal order: "after X, do Y" → X before Y
                        /:   - Data flow: "analyze the cleaned data" → clean first
                        /:   - Keywords: "using", "from", "based on", "with", "given"
                        /:   - Ask: "What do I need to produce this?"
                    <- {refined instruction content}<:{1}>
                    <- {extracted concepts}<:{2}>
                    <- [extracted operations]<:{3}>

                <- [extracted control patterns]
                    <= ::(identify loops and conditions)
                        /: LLM EXTRACTION: Find CONTROL STRUCTURES
                        /:
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#the-five-core-patterns",
                        /:   "documentation/current/4_compilation/examples/ncds/README.md#loop-patterns",
                        /:   "documentation/current/4_compilation/examples/ncds/README.md#control-flow-patterns"
                        /: ]
                        /: CONTEXT NEEDED: What control patterns to look for?
                        /:   - Iteration: "for each X", "process all Y"
                        /:   - Conditional: "if X then Y", "when Z"
                        /:   - Self-seeding loop: "keep going until", "continuously"
                        /:   - Conditional append: "add if valid", "collect matching"
                    <- {refined instruction content}

    <- {phase 2 complete}
        <= ::(write phase 2 status to progress file)
            /: CHECKPOINT: Mark Phase 2 done
        <- {progress file path}<:{1}>
        <- {extraction file written}<:{2}>

    /: ========================================
    /: PHASE 3: CLASSIFICATION
    /: ========================================
    /: PURPOSE: Label each operation with its NormCode pattern type
    /: 
    /: Per derivation.md takeaways, patterns include:
    /:   - Linear chain: A → B → C
    /:   - Multiple inputs: combine(A, B) → C
    /:   - Iteration: for each X in collection
    /:   - Conditional: if condition then A else B
    /:   - Grouping: bundle {A, B, C} together
    /:
    /: This PREPARES for tree construction by labeling HOW each operation behaves

    <- {classifications file written}
        <= ::(write classifications to checkpoint file)
            /: FILE I/O: Save classifications for Phase 4
        <- {classifications file path}<:{1}>
        <- {classifications to be written}<:{2}>
            <= $. %>({classifications to be written})
                /: SELECTION: Cache or compute pattern

            <- <phase 3 already complete>
                <= ::<{check if phase 3 already complete in progress}><ALL True>
                    /: RESUME CHECK
                <- {current progress}
                    <= ::(read progress from file if exists)
                    <- {progress file path}

            <- {cached classifications}
                <= ::(read classifications from checkpoint)
                    /: CACHE PATH
                    <= @:'(<phase 3 already complete>)
                    <* <phase 3 already complete>
                <- {classifications file path}

            <- [freshly classified operations]
                <= *. %>([extracted operations]) %<({classification}) %:({operation}) %@(1)
                    /: ITERATION: Process each operation from Phase 2
                    /: For every operation, determine its pattern type
                    <= @:!(<phase 3 already complete>)
                    <* <phase 3 already complete>

                    <= $. %>({classification})
                        /: LOOP BODY: Return the classification for this operation

                    <- {classification}
                        <= ::(determine pattern type for operation)
                            /: LLM CLASSIFICATION: What pattern does this operation match?
                            /:
                            /: %{cue_files}: [
                            /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#the-five-core-patterns",
                            /:   "documentation/current/4_compilation/examples/ncds/README.md#pattern-reference",
                            /:   "documentation/current/4_compilation/derivation.md#derivation-takeaways-lessons-from-examples"
                            /: ]
                            /: CONTEXT NEEDED: The 5 core patterns
                            /:   1. Linear chain: "Transform A into B" → single input, single output
                            /:   2. Multiple inputs: "Combine A and B" → sibling inputs
                            /:   3. Iteration: "For each X, do Y" → loop with <* marker
                            /:   4. Conditional: "If X then Y" → timing gate with <* condition
                            /:   5. Grouping: "Bundle A, B, C" → collect into structured output
                        <- {current operation}<:{1}>
                        <- {operation context}<:{2}>
                            <= ::(gather context from extraction data)
                                /: PREPARATION: Pull relevant context for this operation
                                /: Context = which concepts it touches, what dependencies involve it
                            <- {current operation}<:{1}>
                            <- {extraction data}<:{2}>

                <- [extracted operations]
                    <= ::(get operations from extraction data)
                        /: DATA ACCESS: Get the list of operations to iterate over
                    <- {extraction data}
                        <= ::(read extraction file from path)
                            /: FILE I/O: Load Phase 2 output
                        <- {extraction file path}

                <* {current operation}<$([extracted operations])*>
                    /: LOOP CONTEXT: The current operation being classified

    <- {phase 3 complete}
        <= ::(write phase 3 status to progress file)
            /: CHECKPOINT: Mark Phase 3 done
        <- {progress file path}<:{1}>
        <- {classifications file written}<:{2}>

    /: ========================================
    /: PHASE 4: TREE CONSTRUCTION
    /: ========================================
    /: PURPOSE: Build the hierarchical dependency structure
    /: 
    /: Per derivation.md Step 4:
    /:   "Start with final output (root)"
    /:   "For each concept, add its operation as child"
    /:   "For each operation, add its inputs as children"
    /:   "Recurse until all concepts placed"
    /:
    /: This is the STRUCTURE step - arranging pieces into a tree

    <- {tree file written}
        <= ::(write dependency tree to checkpoint file)
           /: FILE I/O: Save tree for Phase 5  
        <- {tree file path}<:{1}>
        <- {tree to be written}<:{2}>
            <= $. %>({tree to be written})
            /: SELECTION: Cache or compute pattern

            <- <phase 4 already complete>
                <= ::<{check if phase 4 already complete in progress}><ALL True>
                    /: RESUME CHECK
                <- {current progress}
                    <= ::(read progress from file if exists)
                    <- {progress file path}

            <- {cached dependency tree}
                <= ::(read dependency tree from checkpoint)
                    /: CACHE PATH
                    <= @:'(<phase 4 already complete>)
                    <* <phase 4 already complete>
                <- {tree file path}

            <- {freshly constructed tree}
                <= ::(construct tree from classifications and extractions)
                    /: LLM/ALGORITHMIC: Build the dependency tree
                    /:
                    /: %{cue_files}: [
                    /:   "documentation/current/4_compilation/derivation.md#step-4-build-hierarchical-structure",
                    /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#the-derivation-algorithm",
                    /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#worked-example"
                    /: ]
                    /: CONTEXT NEEDED: Tree construction algorithm
                    /:   1. Start with final output concept as root
                    /:   2. Find operation that produces it → add as child (<=)
                    /:   3. Find inputs to that operation → add as grandchildren (<-)
                    /:   4. For each input with a producing operation → recurse
                    /:   5. Stop when reaching ground concepts (external inputs)
                    /:   6. Add <* markers for loop contexts and conditions
                    <= @:!(<phase 4 already complete>)
                    <* <phase 4 already complete>

                <- {classifications data}
                    <= ::(read classifications file from path)
                        /: FILE I/O: Load Phase 3 output (pattern types)
                    <- {classifications file path}

                <- {extraction data}
                    <= ::(read extraction file from path)
                        /: FILE I/O: Load Phase 2 output (raw materials)
                    <- {extraction file path}

                <- {final output concept}
                    <= ::(identify goal from extraction data)
                        /: LLM IDENTIFICATION: What is the FINAL OUTPUT of this instruction?
                        /:
                        /: %{cue_files}: [
                        /:   "documentation/current/4_compilation/examples/ncds/derivation_v2.md#step-1-identify-the-goal",
                        /:   "documentation/current/4_compilation/derivation.md#strategy-1-top-down-goal-oriented"
                        /: ]
                        /: CONTEXT NEEDED: How to identify the goal
                        /:   - The goal is the FINAL OUTPUT of the instruction
                        /:   - Look for: "produce X", "generate Y", "return Z"
                        /:   - This becomes the ROOT of the tree
                        /:   - Example: "generate a summary" → root is "{summary}"
                    <- {extraction data}

                <- {classified operations}
                    <= ::(get classifications from classifications data)
                        /: DATA ACCESS: Get operation → pattern_type mappings
                    <- {classifications data}

                <- [all dependencies]
                    <= ::(extract dependencies from extraction data)
                        /: DATA ACCESS: Get the dependency relationships
                        /: Format: [{source: X, target: Y, type: "produces"|"feeds_into"}, ...]
                    <- {extraction data}

    <- {phase 4 complete}
        <= ::(write phase 4 status to progress file)
            /: CHECKPOINT: Mark Phase 4 done
        <- {progress file path}<:{1}>
        <- {tree file written}<:{2}>

    /: ========================================
    /: PHASE 5: SERIALIZATION
    /: ========================================
    /: PURPOSE: Convert internal tree structure to .ncds text format
    /: 
    /: Per derivation.md format:
    /:   - <- for value concepts (data)
    /:   - <= for functional concepts (operations)
    /:   - <* for context concepts (loop base, conditions)
    /:   - 4-space indentation for hierarchy
    /:   - Root at level 0, children indented
    /:
    /: This is OUTPUT formatting - tree → text

    <- {ncds output written}
        <= ::(write ncds file to output path)
            /: FILE I/O: Write the final .ncds file
        <- {output file path}<:{1}>
        <- {ncds to be written}<:{2}>
            <= $. %>({ncds to be written})
                /: SELECTION: Cache or compute pattern

            <- <phase 5 already complete>
                <= ::<{check if phase 5 already complete in progress}><ALL True>
                    /: RESUME CHECK
                <- {current progress}
                    <= ::(read progress from file if exists)
                    <- {progress file path}

            <- {cached ncds content}
                <= ::(read ncds from checkpoint)
                    /: CACHE PATH
                    <= @:'(<phase 5 already complete>)
                    <* <phase 5 already complete>
                <- {output file path}

            <- {freshly serialized ncds}
                <= ::(serialize dependency tree to ncds text format)
                    /: ALGORITHMIC/LLM: Convert tree JSON to .ncds text
                    /:
                    /: %{cue_files}: [
                    /:   "documentation/current/4_compilation/derivation.md#the-ncds-format",
                    /:   "documentation/current/4_compilation/examples/ncds/00_simple_linear.ncds",
                    /:   "documentation/current/4_compilation/examples/ncds/02_multi_input.ncds",
                    /:   "documentation/current/4_compilation/examples/ncds/03_iteration.ncds",
                    /:   "documentation/current/4_compilation/examples/ncds/04_conditional.ncds",
                    /:   "documentation/current/4_compilation/examples/ncds/05_grouping.ncds"
                    /: ]
                    /: CONTEXT NEEDED: .ncds format specification
                    /:   Markers:
                    /:     <- : Value concept (data/input/output)
                    /:     <= : Functional concept (operation)
                    /:     <* : Context concept (loop base, condition)
                    /:   Structure:
                    /:     - 4-space indentation per level
                    /:     - Root at level 0
                    /:     - Operation is first child of value
                    /:     - Inputs are siblings after operation
                    /:   Example:
                    /:     <- final result
                    /:         <= compute from inputs
                    /:         <- input A
                    /:         <- input B
                    <= @:!(<phase 5 already complete>)
                    <* <phase 5 already complete>

                <- {dependency tree}
                    <= ::(read dependency tree file from path)
                        /: FILE I/O: Load Phase 4 output (the tree structure)
                    <- {tree file path}

    <- {phase 5 complete}
        <= ::(write phase 5 status to progress file)
            /: CHECKPOINT: Mark Phase 5 done (derivation complete!)
        <- {progress file path}<:{1}>
        <- {ncds output written}<:{2}>

/: ========================================
/: SUMMARY: How Operations Work Together
/: ========================================
/:
/: DERIVATION CORE (per documentation):
/:   Phase 2: EXTRACT → concepts, operations, dependencies, patterns
/:   Phase 4: STRUCTURE → build dependency tree
/:   Phase 5: OUTPUT → serialize to .ncds
/:
/: ENHANCEMENTS (operational):
/:   Phase 1: PRE-PROCESS → handle vague instructions
/:   Phase 3: CLASSIFY → label operations with pattern types
/:   All phases: CHECKPOINT → enable resume on failure
/:
/: DATA FLOW:
/:   instruction.txt 
/:     → [refine if vague] 
/:     → extract {concepts, operations, dependencies, patterns}
/:     → classify each operation
/:     → construct dependency tree
/:     → serialize to .ncds
/:     → ncds_output.ncds
/:
/: RESUME PATTERN (repeated 5x):
/:   1. Check if phase already complete
/:   2. If yes → read cached result
/:   3. If no → compute fresh result
/:   4. Write result to checkpoint
/:   5. Update progress tracker
/:
/: FORMAL OPERATORS USED:
/:   $. %>() - Selection: pick first available from list
/:   &[{}] %>[] %+() - Grouping: bundle items with label
/:   *. %>() %<() %:() %@() - Iteration: for each with output config
/:   @:'() - Timing gate: execute if condition is TRUE
/:   @:!() - Timing gate: execute if condition is NOT true
/:   ::() - Imperative: action/command
/:   ::<{}>< > - Judgement: evaluation with truth assertion
/:   <:{N}> - Value order: positional argument marker
/:   <$()%> - Instance marker: loop variable reference
/:
/: ========================================
/: CUE FILES SUMMARY (for prompt writing)
/: ========================================
/:
/: PHASE 1 - REFINEMENT:
/:   judge if instruction lacks concrete details:
/:     - derivation_v2.md#before-derivation-instruction-refinement
/:     - derivation.md#the-derivation-problem
/:   apply each refinement question:
/:     - derivation_v2.md#the-refinement-questions
/:   synthesize from refinement answers:
/:     - derivation_v2.md#the-refinement-process
/:     - derivation_v2.md#rules-of-thumb-for-paraphrasing
/:
/: PHASE 2 - EXTRACTION:
/:   identify all nouns and data entities:
/:     - derivation.md#step-1-identify-concepts
/:     - semantic_concepts.md#object
/:     - semantic_concepts.md#relation
/:   identify all verbs and actions:
/:     - derivation.md#step-2-identify-operations
/:     - semantic_concepts.md#imperative
/:     - semantic_concepts.md#judgement
/:   identify what needs what:
/:     - derivation.md#step-3-determine-dependencies
/:     - derivation_v2.md#the-derivation-question
/:   identify loops and conditions:
/:     - derivation_v2.md#the-five-core-patterns
/:     - README.md#loop-patterns
/:     - README.md#control-flow-patterns
/:
/: PHASE 3 - CLASSIFICATION:
/:   determine pattern type for operation:
/:     - derivation_v2.md#the-five-core-patterns
/:     - README.md#pattern-reference
/:     - derivation.md#derivation-takeaways-lessons-from-examples
/:
/: PHASE 4 - TREE CONSTRUCTION:
/:   identify goal from extraction data:
/:     - derivation_v2.md#step-1-identify-the-goal
/:     - derivation.md#strategy-1-top-down-goal-oriented
/:   construct tree from classifications and extractions:
/:     - derivation.md#step-4-build-hierarchical-structure
/:     - derivation_v2.md#the-derivation-algorithm
/:     - derivation_v2.md#worked-example
/:
/: PHASE 5 - SERIALIZATION:
/:   serialize dependency tree to ncds text format:
/:     - derivation.md#the-ncds-format
/:     - EXAMPLES: 00_simple_linear.ncds, 02_multi_input.ncds,
/:       03_iteration.ncds, 04_conditional.ncds, 05_grouping.ncds
