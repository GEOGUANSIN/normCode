/: ========================================
/: NormCode Formalization Process
/: ========================================
/:
/: GOAL: Convert .ncds plan text to formal .ncd format
/:
/: FORMALIZATION means:
/:   1. Parse .ncds into structured lines
/:   2. For each concept line, judge type and formalize accordingly
/:   3. Serialize formalized lines back to .ncd text
/:
/: INPUT:  .ncds file (source plan)
/: OUTPUT: .ncd file (formalized plan with flow indices, semantic types, etc.)
/:

:<:{.ncd file}
    <= return the formalized .ncd output
    /: ROOT: The final result is the serialized .ncd file
    /: The real work happens in the phases below

    /: ========================================
    /: GROUND CONCEPTS (External Inputs)
    /: ========================================

    <- {.ncds file}
        /: Ground: source NCDS plan file to be formalized

    /: ========================================
    /: PHASE 1: PARSE
    /: ========================================
    /: Parse the .ncds file into a JSON list of lines
    /: Each line has: flow_index, content, depth, inference_marker, concept_type

    <- [parsed lines]
        <= parse .ncds file into JSON list of lines
        /: Uses parser to convert text to structured data
        <- {.ncds file}

    /: ========================================
    /: PHASE 2: FOR EACH CONCEPT LINE - FORMALIZE
    /: ========================================
    /: For each line that is a concept (not a comment):
    /:   1. Judge what type of concept it is
    /:   2. Apply appropriate formalization based on type
    /:   3. Collect all formalized lines

    <- [formalized lines]
        <= for each concept line in parsed lines
        /: Loop over all concept lines, produce formalized version of each
        /: The looper collects each {formalized line} and joins them into [formalized lines]
            <= return formalized line for this concept
            /: LOOP RETURN: Specifies what gets aggregated into [formalized lines]
            /: This return operation wraps the selection that produces {formalized line}

            <- {formalized line}
                <= select first valid formalization result
                /: CONDITIONAL SELECTION: Based on judged type, apply matching formalization
                /: Only one option will produce a result (timing-gated)

                /: ========================================
                /: STEP 2a: JUDGE CONCEPT TYPE (executed first)
                /: ========================================
                <- {concept type}
                    <= judge what type of concept this line is
                    /: Returns one of: {object}, [relation], <proposition>,
                    /:   ::() imperative, ::<> judgement, $ assigning,
                    /:   & grouping, @ timing, * looping
                    <- {concept line}

                /: ========================================
                /: STEP 2b: CHECK TYPE CONDITIONS (executed second)
                /: ========================================
                <- <is object type>
                    <= check if concept type equals object
                    <- {concept type}

                <- <is relation type>
                    <= check if concept type equals relation
                    <- {concept type}

                <- <is proposition type>
                    <= check if concept type equals proposition
                    <- {concept type}

                <- <is imperative type>
                    <= check if concept type equals imperative
                    <- {concept type}

                <- <is judgement type>
                    <= check if concept type equals judgement
                    <- {concept type}

                <- <is assigning type>
                    <= check if concept type equals assigning
                    <- {concept type}

                <- <is grouping type>
                    <= check if concept type equals grouping
                    <- {concept type}

                <- <is timing type>
                    <= check if concept type equals timing
                    <- {concept type}

                <- <is looping type>
                    <= check if concept type equals looping
                    <- {concept type}

                /: ========================================
                /: STEP 2c: APPLY FORMALIZATION (executed third)
                /: ========================================
                /: Only the matching type's formalization will execute (timing-gated)

                <- {object formalized}
                    <= formalize according to {object} syntax
                        <= when condition holds
                        <* <is object type>
                    <- {concept line}

                <- {relation formalized}
                    <= formalize according to [relation] syntax
                        <= when condition holds
                        <* <is relation type>
                    <- {concept line}

                <- {proposition formalized}
                    <= formalize according to <proposition> syntax
                        <= when condition holds
                        <* <is proposition type>
                    <- {concept line}

                <- {imperative formalized}
                    <= formalize according to ::() imperative syntax
                    /: Add annotation: | ?{sequence}: imperative
                        <= when condition holds
                        <* <is imperative type>
                    <- {concept line}

                <- {judgement formalized}
                    <= formalize according to ::<> judgement syntax
                    /: Add annotation: | ?{sequence}: judgement
                        <= when condition holds
                        <* <is judgement type>
                    <- {concept line}

                <- {assigning formalized}
                    <= formalize according to $ assigning syntax
                    /: Add annotation: | ?{sequence}: assigning
                        <= when condition holds
                        <* <is assigning type>
                    <- {concept line}

                <- {grouping formalized}
                    <= formalize according to & grouping syntax
                    /: Add annotation: | ?{sequence}: grouping
                        <= when condition holds
                        <* <is grouping type>
                    <- {concept line}

                <- {timing formalized}
                    <= formalize according to @ timing syntax
                    /: Add annotation: | ?{sequence}: timing
                        <= when condition holds
                        <* <is timing type>
                    <- {concept line}

                <- {looping formalized}
                    <= formalize according to * looping syntax
                    /: Add annotation: | ?{sequence}: looping
                        <= when condition holds
                        <* <is looping type>
                    <- {concept line}

        /: === Loop input and context ===
        <- [parsed lines]
        <* {concept line}
            /: Loop context: the current concept line being processed

    /: ========================================
    /: PHASE 3: SERIALIZE
    /: ========================================
    /: Convert the formalized lines back to .ncd text format

    <- {serialized .ncd content}
        <= serialize formalized lines to .ncd text format
        /: Uses parser to convert structured data back to text
        /: Produces the final .ncd file content
        <- [formalized lines]
        <- {.ncds file}
            /: Need original file for structure reference during serialization

