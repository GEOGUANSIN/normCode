/: ========================================
/: Formalization Algorithm
/: ========================================
/: 
/: GOAL: Transform .ncds (draft) into .ncd (formal) with:
/:   - Flow indices (unique hierarchical addresses)
/:   - Sequence types (operation classification)
/:   - Semantic types (concept classification)
/:   - Value bindings (input ordering)
/:
/: INPUT:  ncds_content (string)
/: OUTPUT: ncd_content (string)
/:
/: PROCESSING: Inference-by-inference with global context
/:
/: CHECKPOINTING: Each phase writes to checkpoint file for resumability

:<: ncd content
    <= return ncd output written
    /: ROOT: The final formalized .ncd content

    /: ========================================
    /: GROUND CONCEPTS (External Inputs)
    /: ========================================

    <- ncds input file path
        /: Ground: Path to the .ncds file to formalize

    <- progress file path
        /: Ground: Tracks which phases completed

    <- parsed structure file path
        /: Ground: Phase 1 checkpoint

    <- indexed structure file path
        /: Ground: Phase 2 checkpoint

    <- typed structure file path
        /: Ground: Phase 3-4 checkpoint

    <- output file path
        /: Ground: Final .ncd output path

    /: ========================================
    /: PHASE 0: READ INPUT
    /: ========================================

    <- ncds content
        <= read ncds from input file
        /: FILE I/O: Load the .ncds content
        <- ncds input file path

    /: ========================================
    /: PHASE 1: PARSE NCDS STRUCTURE
    /: ========================================
    /: PURPOSE: Convert text into structured tree representation
    /:
    /: - Tokenize each line (marker, content, indentation)
    /: - Build parent-child relationships from indentation
    /: - Identify ground concepts (leaves without producers)

    <- parsed structure file written
        <= write parsed structure to checkpoint
        /: CHECKPOINT: Save parsed tree for resume

        <- parsed structure file path
        <- parsed structure to be written
            <= select first available result
            /: SELECTION: Cache or compute

            <- phase 1 already complete?
                <= check if phase 1 already complete in progress
                <- current progress
                    <= read progress from file if exists
                    <- progress file path

            <- cached parsed structure
                <= read parsed structure from checkpoint
                    <= if phase 1 already complete
                    <* phase 1 already complete?
                <- parsed structure file path

            <- freshly parsed structure
                <= parse ncds text into tree structure
                /: LLM/SCRIPT: Parse the ncds content
                /:
                /: For each line:
                /:   1. Extract marker (<-, <=, <*, /:, :<:)
                /:   2. Extract content (text after marker)
                /:   3. Calculate indentation level (spaces / 4)
                /:   4. Build parent-child tree from levels
                /:
                /: Output: JSON tree with nodes containing:
                /:   - marker, content, level, children[]
                    <= if phase 1 NOT already complete
                    <* phase 1 already complete?
                <- ncds content

    <- phase 1 complete
        <= write phase 1 status to progress
        <- progress file path
        <- parsed structure file written

    /: ========================================
    /: PHASE 2: ASSIGN FLOW INDICES
    /: ========================================
    /: PURPOSE: Give each node a unique hierarchical address
    /:
    /: - Root gets "1"
    /: - Children get parent.1, parent.2, etc.
    /: - All concept lines get indices

    <- indexed structure file written
        <= write indexed structure to checkpoint
        /: CHECKPOINT: Save tree with flow indices

        <- indexed structure file path
        <- indexed structure to be written
            <= select first available result

            <- phase 2 already complete?
                <= check if phase 2 already complete in progress
                <- current progress

            <- cached indexed structure
                <= read indexed structure from checkpoint
                    <= if phase 2 already complete
                    <* phase 2 already complete?
                <- indexed structure file path

            <- freshly indexed structure
                <= assign flow indices to tree
                /: SCRIPT: Traverse tree and assign indices
                /:
                /: Algorithm:
                /:   assign_index(root, "1")
                /:   for each node:
                /:     node.flow_index = current_index
                /:     for i, child in enumerate(children, 1):
                /:       assign_index(child, current_index + "." + i)
                    <= if phase 2 NOT already complete
                    <* phase 2 already complete?
                <- parsed structure
                    <= read parsed structure from checkpoint
                    <- parsed structure file path

    <- phase 2 complete
        <= write phase 2 status to progress
        <- progress file path
        <- indexed structure file written

    /: ========================================
    /: PHASE 3: DETERMINE SEQUENCE TYPES
    /: ========================================
    /: PURPOSE: Classify each functional concept
    /:
    /: Check syntactic operators first:
    /:   $= $. $+ $- $% → assigning
    /:   &[{}] &[#] → grouping
    /:   @:' @:! @. → timing
    /:   *. → looping
    /:
    /: If no operator, infer from NL:
    /:   action verbs → imperative
    /:   evaluation phrases → judgement

    <- typed structure file written
        <= write typed structure to checkpoint
        /: CHECKPOINT: Save tree with sequence and semantic types

        <- typed structure file path
        <- typed structure to be written
            <= select first available result

            <- phase 3 already complete?
                <= check if phase 3 already complete in progress
                <- current progress

            <- cached typed structure
                <= read typed structure from checkpoint
                    <= if phase 3 already complete
                    <* phase 3 already complete?
                <- typed structure file path

            <- freshly typed structure
                <= process inferences with types and bindings
                /: MAIN PROCESSING: For each inference in tree
                    <= if phase 3 NOT already complete
                    <* phase 3 already complete?

                <- indexed structure
                    <= read indexed structure from checkpoint
                    <- indexed structure file path

                <- all inferences processed
                    <= for each inference in tree
                    /: ITERATION: Process one inference at a time

                    <- processed inference
                        <= process single inference
                        /: For this inference:
                        /:   1. If functional: determine sequence type
                        /:   2. Add semantic type ({}, [], <>, ::(), ::<>)
                        /:   3. If multi-input: add value bindings
                        <- current inference
                        <- inference context
                            <= gather context for inference
                            /: Get parent, siblings, tree position
                            <- current inference
                            <- indexed structure

                    <- all inferences
                        <= extract inferences from tree
                        <- indexed structure
                    <* current inference

    <- phase 3 complete
        <= write phase 3 status to progress
        <- progress file path
        <- typed structure file written

    /: ========================================
    /: PHASE 4: SERIALIZE TO NCD
    /: ========================================
    /: PURPOSE: Convert annotated tree back to text format
    /:
    /: Format each line as:
    /:   [marker] [semantic_type][content][binding] | ?{flow_index}: X.Y.Z [| ?{sequence}: type]
    /:
    /: Mark root with :<:

    <- ncd output written
        <= write ncd file to output path

        <- output file path
        <- ncd content to be written
            <= select first available result

            <- phase 4 already complete?
                <= check if phase 4 already complete in progress
                <- current progress

            <- cached ncd content
                <= read ncd from checkpoint
                    <= if phase 4 already complete
                    <* phase 4 already complete?
                <- output file path

            <- freshly serialized ncd
                <= serialize typed tree to ncd format
                /: Convert tree back to formatted text
                /:
                /: For each node in tree order:
                /:   1. Apply indentation (level * 4 spaces)
                /:   2. Format marker and content with types
                /:   3. Append flow index annotation
                /:   4. Append sequence type if functional
                /:   5. Handle root marker (:<:)
                    <= if phase 4 NOT already complete
                    <* phase 4 already complete?
                <- typed structure
                    <= read typed structure from checkpoint
                    <- typed structure file path

    <- phase 4 complete
        <= write phase 4 status to progress
        <- progress file path
        <- ncd output written

/: ========================================
/: SUMMARY
/: ========================================
/:
/: Phase 1: PARSE     ncds text → tree structure
/: Phase 2: INDEX     tree → tree with flow indices
/: Phase 3: TYPE      tree → tree with sequence/semantic types and bindings
/: Phase 4: SERIALIZE tree → ncd text
/:
/: Each phase:
/:   1. Check if already complete (resume support)
/:   2. If yes → read from checkpoint
/:   3. If no → compute and write checkpoint
/:   4. Update progress tracker
/:
/: Key insight: Phase 3 processes inference-by-inference
/: with context from the indexed structure, allowing
/: focused LLM prompts for type determination.

