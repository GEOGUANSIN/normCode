## **Phase 3: Contextualization and Plan Formalization**

This phase takes the semi-formal `.ncd` plan, enriches it with the necessary context, and formalizes it into a preliminary `.nc` file. It transforms the comprehensive `Initial Context Block` into focused, local contexts and links them to uniquely identified inferences in the plan.

### **Step 3.1: Plan Formalization**

Before context can be distributed, the plan itself must be formalized. This step converts the annotated **NormCode Draft (`.ncd`)** into a preliminary, parsable **NormCode (`.nc`)** file. This involves two actions:

1.  **Generating Flow Indices:** The system parses the hierarchical structure of the `.ncd` file and assigns a unique, dot-delimited `flow_index` (e.g., `1.1`, `1.1.2`) to each inference.
2.  **Stripping Annotations:** All descriptive annotations (`?:`, `/:`) are removed, leaving a clean, machine-readable structure.

The output is a preliminary `.nc` file where every inference can be uniquely identified by the combination of its `flow_index` and its functional concept.

### **Step 3.2: Automated Context Distribution**

With a formalized plan, the system can now accurately distribute the context. It feeds two artifacts to an LLM guided by a specialized meta-prompt:

1.  The newly created **NormCode (`.nc`)** file.
2.  The **Initial Context Block** from Phase 1.

The LLM's task is to act as a context-aware analyst. It iterates through each inference in the `.nc` file and determines which specific pieces of the `Initial Context Block` are necessary and sufficient for that inference to be executed correctly. A key part of this process is identifying when multiple inferences require the exact same local context. When such an overlap is found, the LLM creates a single, shared context file to be referenced by all relevant inferences, thus avoiding redundancy.

-   **Input:** The `.nc` file and the `Initial Context Block`.
-   **LLM Process:** For each inference, the model selects only the relevant details from the `Initial Context Block`, creating a tailored, minimal-but-complete local context. It then de-duplicates these local contexts to create a set of unique context files, some of which may be shared.
-   **Output:** A **`context_store` directory** and a **`context_manifest.json`** file.
       - The `context_store` directory contains a separate `.txt` file for each unique local context. Files used by only one inference are named after their inference ID. Files shared by multiple inferences follow a distinct naming pattern (e.g., `shared---<description>.txt`).
       - The `context_manifest.json` file acts as an index, mapping the full inference ID to the file path of its corresponding context file. Multiple inferences can point to the same shared context file.

**Example:**

-   **Input (`.nc` snippet):**
    ```normcode
    ...
    3.1 ::(log validation success)
        <= ...
    ...
    3.2 ::(log validation failure)
        <= ...
    ...
    4.1 ::(create user account)
        <= ...
    ...
    ```
-   **Input (`Initial Context Block`):**
    `"All logging should be sent to the 'audit-log' service via the 'log_event' tool. The user account creation should be done against the 'users' table in the PostgreSQL database."`
-   **Output (Directory Structure & File Contents):**
 
   - **`context_store/`**
     - **`shared---logging_details.txt`**
       ```
       All logging should be sent to the 'audit-log' service via the 'log_event' tool.
       ```
     - **`4.1---create_user_account.txt`**
       ```
       The user account creation should be done against the 'users' table in the PostgreSQL database.
       ```
 
   - **`context_manifest.json`**
     ```json
     {
       "context_mapping": {
         "3.1 ::(log validation success)": "./context_store/shared---logging_details.txt",
         "3.2 ::(log validation failure)": "./context_store/shared---logging_details.txt",
         "4.1 ::(create user account)": "./context_store/4.1---create_user_account.txt"
       }
     }
     ```

### **Step 3.3: Manual Review and Refinement (Optional)**

After the automated distribution, the generated `context_store` directory and its manifest are available for review. A developer can inspect the individual context files and the mapping to ensure that each inference has received the correct contextâ€”nothing more, nothing less. This step allows for fine-tuning that can be critical for the final materialization phase.
