### Step 2.2: Automated Natural Language Translation

**Objective:** To translate the annotated and structured `deconstruction_draft.ncd` into a clean, human-readable `natural_translation.ncn` format. This step makes the plan accessible for manual review by stripping away machine-focused annotations and presenting the core logic in plain language.

The translation is guided by the specifications in the `shared---file_formats_guide.md` and the full set of NormCode syntax and terminology guides.

---
### Example Walkthrough

This example shows how the formal, annotated deconstruction of "Phase 1" is translated into a clear, natural language summary.

**1. Input (`2.1_deconstruction_draft.ncd` snippet):**

This is the machine-focused draft, rich with annotations (`?:`, `/:`) that explain the AI's reasoning during the deconstruction process.

```normcode
<- {Phase 1: Confirmation of Instruction}
    ?: How is {Phase 1} specified?
    <= &across
        /: This phase is specified as a series of steps.
    <- {step 1.1: Automated Instruction Distillation}
        ...: 1.1. Given a raw user prompt and system context...
    <- {step 1.2: Automated Context Registration}
        ...: 1.2. Following the distillation of the instruction...
    <- {step 1.3: Manual Review of Confirmation}
        ...: 1.3. To meticulously review and refine the outputs...
```

**2. LLM Translation Process:**

An LLM parses the `.ncd` snippet, focusing on the core concepts (`{...}`) while ignoring the reasoning annotations (`?:`, `/:`) and unprocessed source text (`...:`). It then rephrases the hierarchical structure into a readable, indented list.

**3. Output (`2.2_natural_translation.ncn` snippet):**

This is the human-readable output, which preserves the plan's structure but presents its logic in clear, natural language.

```ncn
The first phase is Confirmation of Instruction.
    <= This phase is specified as a series of steps.
    <- The first step is Automated Instruction Distillation.
    <- The second step is Automated Context Registration.
    <- The third step is Manual Review of Confirmation.
```
---
# NormCode File Format Guide

This document explains the purpose and characteristics of the three primary file formats used in the NormCode AI Planning Pipeline: `.ncd`, `.ncn`, and `.nc`.

---

## 1. `.ncd` - NormCode Draft

The **annotated blueprint** of the plan, designed for human review and debugging of the translation logic.

**Key Characteristics:**
-   **Semi-Formal:** Uses formal syntax but is not yet ready for execution.
-   **Rich with Annotations:** Includes `?:` (Question), `/:` (Description), and `...:` (Source Text) to document the translation process.
-   **Hierarchical:** Preserves the full, indented structure of the plan's logic.

---

## 2. `.ncn` - NormCode Natural

The **readable summary** of the plan, optimized for clarity and quick comprehension.

**Key Characteristics:**
-   **Natural Language Concepts:** Formal NormCode concepts are replaced with descriptive sentences.
-   **Structure Preservation:** Maintains the exact same hierarchical structure as the `.ncd` file.
-   **No Annotations:** All annotations (`?:`, `/:`, `...:`) are stripped out.

---

## 3. `.nc` - NormCode (Formal)

The **formal, machine-readable script** that is ready for the Orchestrator to execute.

**Key Characteristics:**
-   **Fully Formal:** The syntax is strict, consistent, and designed to be parsed.
-   **No Annotations:** All descriptive annotations are removed.
-   **Execution-Critical Information:** Enriched with `flow_indices` for unique identification of each inference, `agent sequence types`, and formalized operators.
---
# NormCode Guide - Core Syntax

This document covers the fundamental syntax of NormCode, a semi-formal language for constructing a **plan of inferences**.

## Core Syntax: Concepts and Inferences

The fundamental unit of a Normcode plan is the **inference**. An inference is defined by a functional concept and its associated value concepts.

-   **Functional Concept (`<=`)**: This is the cornerstone of an inference. It "pins down" the inference by defining its core logic, function, or operation. Crucially, the functional concept is responsible for **invoking an agent's sequence** (e.g., `quantifying`, `imperative`), which is the underlying engine that executes the inference's logic.

-   **Value Concept (`<-`)**: This concept provides the concrete data for the inference. It specifies the inputs, outputs, parameters, or results that the functional concept operates on or produces.

The entire plan is represented in a hierarchical, vertical format. An inference begins with a root concept, followed by an indented functional concept (`<=`) that defines the operation. The value concepts (`<-`) are then supplied at the same or a more deeply nested level.

A line in Normcode can also have optional annotations for clarity and control:

`_concept_definition_ | _annotation_ // _comment_`

-   **`_concept_definition_`**: The core functional (`<=`) or value (`<-`) statement.
-   **`_annotation_`**: Optional metadata following the `|` symbol. This can be a **flow index** (e.g., `1.1.2`), an intended **data reference**, or the name of the invoked **agent's sequence**.
-   **`// _comment_`**: Human-readable comments.

**Example Structure of an Inference:**
```Normcode
_concept_to_infer_ // The overall goal of this inference
    <= _functional_concept_defining_the_operation_ | 
    quantifying // This invokes the 'quantifying' agent's sequence
    <- _input_value_concept_1_ // This is an input for the 
    operation
    <- _input_value_concept_2_
```
---
# NormCode Guide - Semantical Concepts

Concepts are the building blocks of NormCode. Semantical concepts define the core entities and logical constructs of the domain. They can be subdivided into typically non-functional and functional types.

### Typically Non-Functional Concept Types
These concepts represent entities, their relationships, or their roles in the inference.

| Symbol                | Name                      | Description                                                                 |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- |
| `{}`                  | Object                    | Represents a generic object or entity.                                      |
| `<>`                  | Statement                 | Represents a proposition or a state of affairs (non-functional).            |
| `[]`                  | Relation                  | Represents a relationship between two or more concepts.                     |
| `:S:`                 | Subject                   | Marks the subject of a relation or statement.                               |
| `:>:`                 | Input                     | A special type of Subject that marks a concept as an input parameter.       |
| `:<:`                 | Output                    | A special type of Subject that marks a concept as an output value.          |

**Examples:**
- **Object (`{}`):** `{new number pair}` declares a concept that will hold the state of the two numbers as they are processed.
- **Statement (`<>`):** `<all number is 0>` represents a condition that can be evaluated. The `judgement` agent's sequence will determine if this statement is true or false.
- **Relation (`[]`):** `[all {unit place value} of numbers]` defines a collection that will hold the digits from a specific place value of the numbers being added.

### Typically Functional Concept Types
These concepts define operations or evaluations that often initiate an inference.

| Symbol                | Name                      | Description                                                                 |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- |
| `({})` or `::()`      | Imperative                | Represents a command or an action to be executed.                           |
| `<{}>` or `<...>`     | Judgement                 | Represents an evaluation that results in a boolean-like assessment.         |

**Examples:**
- **Imperative (`::()`):** `::(get the {1}?<$({remainder})%_> of {2}<$({digit sum})%_> divided by 10)` issues a command to a tool or model to perform a calculation. This is the heart of an `imperative` inference.
- **Judgement (`<...>`):** `<= :%(True):<{1}<$({carry-over number})%_> is 0>` evaluates whether the carry-over is zero. This is the core of a `judgement` inference. Note the use of `<...>` as a common syntax variant for a judgement.
---
# NormCode Guide - Syntactical Concepts

Syntactical concepts are operators that control the logic, flow, and manipulation of data within the plan of inferences. They are grouped by their function.

### Assigning Operators

| Symbol | Name           | Description                                                        |
| ------ | -------------- | ------------------------------------------------------------------ |
| `$=`   | Identity     | Assigns a value to a concept, often used for state updates.          |
| `$.`   | Specification  | Specifies or isolates a particular property of a concept.          |
| `$%`   | Abstraction    | Creates a general template from a concrete instance for reuse.     |
| `$+`   | Continuation   | Appends or adds to a concept, often used in loops to update state. |

### Timing (Sequencing) Operators

| Symbol     | Name      | Description                               |
| ---------- | --------- | ----------------------------------------- |
| `@if`      | If        | Executes if a condition is true.          |
| `@if!`     | If Not    | Executes if a condition is false.         |
| `@after`   | After     | Executes after a preceding step is complete. |

### Grouping Operators

| Symbol    | Name   | Description                                           |
| --------- | ------ | ----------------------------------------------------- |
| `&in`     | In     | Groups items contained within a larger collection.    |
| `&across` | Across | Groups items by iterating across a collection.        |

### Quantifying (Listing) Operators

| Symbol   | Name  | Description                                        |
| -------- | ----- | -------------------------------------------------- |
| `*every` | Every | Iterates over every item in a collection (a loop). |

### Concept Markers
These markers can be appended to concepts to modify their meaning.

| Symbol                | Name                 | Description                                                                 |
| --------------------- | -------------------- | --------------------------------------------------------------------------- |
| `?`                   | Conception Query     | Appended to a concept to query its value or definition. E.g., `{sum}?`. |
| `<:_number_>`         | Value Position       | To link a positional placeholder for values (e.g., `<:{1}>`, `<:{2}>`).     |
| `<$(_concept_)%_>`    | Instance Marker      | Marks a concept as an instance of an "umbrella" concept. E.g. `<$({number})%_>` |
| `<$={_number_}>`      | Identity Marker      | Identifies the same concept across different occurrences. E.g. `<$={1}>`     |
| `%:[_concept_]`       | Axis Specifier       | Specifies the `by_axis` for an operation. E.g. `%:[{number pair}]`        |
| `@(_number_)`         | Quantifier Index     | Specifies the index for a quantifier (`*every`) operation. E.g. `@(1)`       |
| `*_number_`           | Quantifier Version   | Links a concept to a specific quantifier iteration. E.g. `{number pair}*1`  |
