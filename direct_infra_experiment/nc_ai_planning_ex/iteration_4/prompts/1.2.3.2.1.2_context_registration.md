# The NormCode AI Planning Pipeline

## Project Goal

The project goal is to bootstrap from a high-level natural language prompt into a structured and executable plan using a meta-algorithmic pipeline. This pipeline, itself powered by a NormCode plan, methodically transforms an instruction by:

1.  **Distilling** the user's intent into a clean instruction and registering all raw context.
2.  **Deconstructing** the instruction into a formal, hierarchical NormCode plan (`.ncd`).
3.  **Contextualizing** the plan by enriching each formal step with precise, granular context.
4.  **Materializing** the final plan into an executable script, ready for an orchestrator.

This creates a system that can understand, decompose, contextualize, and act upon complex instructions in a transparent and repeatable manner.

## Core Inputs

Each iteration of the pipeline begins with two primary markdown files that define the scope and methodology of the task:

-   **`prompts/0_original_prompt.md`**: This file contains the high-level goal that is the target of the decomposition process. It defines the "what" that the pipeline needs to accomplish.
-   **`_meta_pipeline_prompt.md`**: This file documents the methodology used to bootstrap the entire process. It defines the "how" the decomposition and planning will be executed.

For the purpose of this project, these two files are kept synchronized and are updated dynamically through manual modifications to reflect the most current practices and understanding of the pipeline itself.

## The Four-Phase Pipeline

The pipeline is divided into four distinct phases, each with a specific objective:

1.  **Phase 1: Confirmation of Instruction**: Transforms the initial, conversational user prompt into a set of clean, structured inputs (an `Instruction Block` and a `Context Manifest`). This phase includes an opportunity for manual review to ensure accuracy.

2.  **Phase 2: Deconstruction into NormCode Plan**: Translates the clean `Instruction Block` into a semi-formal NormCode Draft (`.ncd`). This draft represents the logical structure of the plan and is designed for human review.

3.  **Phase 3: Contextualization and Plan Formalization**: Enriches the plan with specific, relevant context. It converts the `.ncd` draft into a formal `.nc` file with unique identifiers (`flow_index`) for each step and distributes context from a `context_store` to each of those steps.

4.  **Phase 4: Materialization into an Executable Script**: Translates the final, formalized `.nc` plan and its context map into a runnable Python script, ready for execution by an `Orchestrator`.

This structured, phased approach ensures that a high-level, ambiguous instruction can be methodically transformed into a precise, executable, and context-aware plan.



---
### Step 1.2: Automated Context Registration

Following the distillation of the instruction, the system identifies and registers all non-procedural information required for the plan. This "world knowledge" can come from various sources, including system context, constraints mentioned in the prompt, or a set of pre-existing authoritative documents.

The goal is to produce a structured and self-contained registration of this knowledge. This consists of two components:

1.  **`context_store` Directory:** A directory is created to hold copies of all raw, authoritative source documents (e.g., technical guides, original prompts, background information). This ensures the context is portable and complete.
2.  **Context Manifest File (e.g., `.json`):** A structured file that acts as a high-level summary and an index to the files in the `context_store`. It provides a machine-readable map of the available context.

---
*From Project Context:*

#### **Example: Registering Authoritative Documents**

In many cases, the context is not a small piece of information but a collection of detailed documents that provide foundational knowledge. The registration process involves identifying references to these documents within the user prompt or system context, and then creating a manifest that catalogs them.

-   **Input (User Prompt):** "Please execute the meta-pipeline as described in `prompt.md`. Use the `normcode_terminology_guide.md` for definitions and `file_formats_guide.md` for file specifications."

-   **LLM Process:** The model is instructed to analyze the prompt, identify all mentioned file references, and create a manifest that summarizes the purpose of each document and provides a file reference for the `context_store`.

-   **Output:**
    1.  The `context_store` is populated with copies of the referenced files (`raw--prompt.md`, `raw--context_normcode_terminology_guide.md`, etc.).
    2.  A **Context Manifest File** is generated:
    ```json
    {
      "summary": "This context block provides the high-level summary and references for the NormCode AI Planning Pipeline...",
      "sections": [
        {
          "title": "Core Methodology and Examples",
          "description": "A complete, practical walkthrough of this pipeline...is provided in raw--prompt.md.",
          "file_reference": "./context_store/raw--prompt.md"
        },
        {
          "title": "Technical Language Specification",
          "description": "The complete technical reference for the language...is detailed in raw--normcode_terminology_guide.md.",
          "file_reference": "./context_store/raw--normcode_terminology_guide.md"
        },
        {
          "title": "File Format Specifications",
          "description": "The specifications for the various file formats...are detailed in raw--file_formats_guide.md.",
          "file_reference": "./context_store/raw--file_formats_guide.md"
        }
      ]
    }
    ```

---

