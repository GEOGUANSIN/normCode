### Step 2.4: Manual Review of Deconstruction

**Objective:** Review and validate the logical structure of the NormCode plan generated from the instruction block.

**Procedure:**

1.  **Examine `2.1_deconstruction_draft.ncd`:**
    *   Trace the flow of inferences (`<-`) to ensure they logically connect.
    *   Review the annotations (`/:` and `?:`) to confirm that the reasoning behind the structure is sound.
    *   Verify that all requirements from the instruction block have been captured.

2.  **Examine `2.2_natural_translation.ncn`:**
    *   Read the plain-text version of the plan to ensure its intent is clear and matches the requirements.
    *   Use this file as a high-level guide to understanding the more formal `.ncd` file.

3.  **Examine `2.3_deconstruction.nc`:**
    *   Review the formalized plan to ensure it accurately reflects the structure of the `.ncd` and is ready for contextualization.

**Outcome:** A logically sound and validated plan structure, ready for the contextualization phase.
---
# NormCode File Format Guide

This document explains the purpose and characteristics of the three primary file formats used in the NormCode AI Planning Pipeline: `.ncd`, `.ncn`, and `.nc`.

---

## 1. `.ncd` - NormCode Draft

The **annotated blueprint** of the plan, designed for human review and debugging of the translation logic.

**Key Characteristics:**
-   **Semi-Formal:** Uses formal syntax but is not yet ready for execution.
-   **Rich with Annotations:** Includes `?:` (Question), `/:` (Description), and `...:` (Source Text) to document the translation process.
-   **Hierarchical:** Preserves the full, indented structure of the plan's logic.

---

## 2. `.ncn` - NormCode Natural

The **readable summary** of the plan, optimized for clarity and quick comprehension.

**Key Characteristics:**
-   **Natural Language Concepts:** Formal NormCode concepts are replaced with descriptive sentences.
-   **Structure Preservation:** Maintains the exact same hierarchical structure as the `.ncd` file.
-   **No Annotations:** All annotations (`?:`, `/:`, `...:`) are stripped out.

---

## 3. `.nc` - NormCode (Formal)

The **formal, machine-readable script** that is ready for the Orchestrator to execute.

**Key Characteristics:**
-   **Fully Formal:** The syntax is strict, consistent, and designed to be parsed.
-   **No Annotations:** All descriptive annotations are removed.
-   **Execution-Critical Information:** Enriched with `flow_indices` for unique identification of each inference, `agent sequence types`, and formalized operators.
---
# NormCode Translation Fundamentals

This document provides a consolidated overview of the core concepts of NormCode that are essential for the translation process.

### 1.1. Core Structure
An inference starts with a concept to be defined, followed by:
-   `<=` **Functional Concept**: Defines the core operation (e.g., performing an action, specifying a value).
-   `<-` **Value Concept**: Provides the data or inputs for the operation.

### 1.2. Semantical Concept Types (The "Words")
These define the core entities and logical constructs. They are divided into two main groups:
*   **Object-like (Static entities):**
    *   `{}` **Object**: A thing, variable, or piece of data. (e.g., `{user name}`).
    *   `<>` **Statement**: An assertion of fact that can be evaluated. (e.g., `<user is an admin>`).
    *   `[]` **Relation**: A group or collection of concepts. (e.g., `[all {user emails}]`).
*   **Action-like (Processes/evaluations):**
    *   `::()` **Imperative**: A command or action to be executed. (e.g., `::(calculate total)`).
    *   `::< >` **Judgement**: The *act* of evaluating a statement's truth. (e.g., `::<is the user an admin?>`).

### 1.3. Subject Markers (Concept Roles)
Concepts are often prefixed to define their role in an inference:
-   `:S:` **Subject**: The primary subject of a block.
-   `:>:` **Input**: Marks a concept as an input parameter.
-   `:<:` **Output**: Marks a concept as an output value. This is frequently used to frame the top-level goal of the entire plan.

### 1.4. Annotations (Process State)
Annotations manage the state of the translation process:
-   `...:` **Source Text**: Holds the piece of the original natural language (`normtext`) currently being analyzed. A concept with a `...:` annotation is considered "un-decomposed."
-   `?:` **Question**: The question being asked about the source text to guide the decomposition.
-   `/:` **Description**: A human-readable summary of the result of a decomposition, marking a concept as definitive and complete.
---
# NormCode Guide - Core Syntax

This document covers the fundamental syntax of NormCode, a semi-formal language for constructing a **plan of inferences**.

## Core Syntax: Concepts and Inferences

The fundamental unit of a Normcode plan is the **inference**. An inference is defined by a functional concept and its associated value concepts.

-   **Functional Concept (`<=`)**: This is the cornerstone of an inference. It "pins down" the inference by defining its core logic, function, or operation. Crucially, the functional concept is responsible for **invoking an agent's sequence** (e.g., `quantifying`, `imperative`), which is the underlying engine that executes the inference's logic.

-   **Value Concept (`<-`)**: This concept provides the concrete data for the inference. It specifies the inputs, outputs, parameters, or results that the functional concept operates on or produces.

The entire plan is represented in a hierarchical, vertical format. An inference begins with a root concept, followed by an indented functional concept (`<=`) that defines the operation. The value concepts (`<-`) are then supplied at the same or a more deeply nested level.

A line in Normcode can also have optional annotations for clarity and control:

`_concept_definition_ | _annotation_ // _comment_`

-   **`_concept_definition_`**: The core functional (`<=`) or value (`<-`) statement.
-   **`_annotation_`**: Optional metadata following the `|` symbol. This can be a **flow index** (e.g., `1.1.2`), an intended **data reference**, or the name of the invoked **agent's sequence**.
-   **`// _comment_`**: Human-readable comments.

**Example Structure of an Inference:**
```Normcode
_concept_to_infer_ // The overall goal of this inference
    <= _functional_concept_defining_the_operation_ | 
    quantifying // This invokes the 'quantifying' agent's sequence
    <- _input_value_concept_1_ // This is an input for the 
    operation
    <- _input_value_concept_2_
```
---
# NormCode Guide - Semantical Concepts

Concepts are the building blocks of NormCode. Semantical concepts define the core entities and logical constructs of the domain. They can be subdivided into typically non-functional and functional types.

### Typically Non-Functional Concept Types
These concepts represent entities, their relationships, or their roles in the inference.

| Symbol                | Name                      | Description                                                                 |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- |
| `{}`                  | Object                    | Represents a generic object or entity.                                      |
| `<>`                  | Statement                 | Represents a proposition or a state of affairs (non-functional).            |
| `[]`                  | Relation                  | Represents a relationship between two or more concepts.                     |
| `:S:`                 | Subject                   | Marks the subject of a relation or statement.                               |
| `:>:`                 | Input                     | A special type of Subject that marks a concept as an input parameter.       |
| `:<:`                 | Output                    | A special type of Subject that marks a concept as an output value.          |

**Examples:**
- **Object (`{}`):** `{new number pair}` declares a concept that will hold the state of the two numbers as they are processed.
- **Statement (`<>`):** `<all number is 0>` represents a condition that can be evaluated. The `judgement` agent's sequence will determine if this statement is true or false.
- **Relation (`[]`):** `[all {unit place value} of numbers]` defines a collection that will hold the digits from a specific place value of the numbers being added.

### Typically Functional Concept Types
These concepts define operations or evaluations that often initiate an inference.

| Symbol                | Name                      | Description                                                                 |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- |
| `({})` or `::()`      | Imperative                | Represents a command or an action to be executed.                           |
| `<{}>` or `<...>`     | Judgement                 | Represents an evaluation that results in a boolean-like assessment.         |

**Examples:**
- **Imperative (`::()`):** `::(get the {1}?<$({remainder})%_> of {2}<$({digit sum})%_> divided by 10)` issues a command to a tool or model to perform a calculation. This is the heart of an `imperative` inference.
- **Judgement (`<...>`):** `<= :%(True):<{1}<$({carry-over number})%_> is 0>` evaluates whether the carry-over is zero. This is the core of a `judgement` inference. Note the use of `<...>` as a common syntax variant for a judgement.
---
# NormCode Guide - Syntactical Concepts

Syntactical concepts are operators that control the logic, flow, and manipulation of data within the plan of inferences. They are grouped by their function.

### Assigning Operators

| Symbol | Name           | Description                                                        |
| ------ | -------------- | ------------------------------------------------------------------ |
| `$=`   | Identity     | Assigns a value to a concept, often used for state updates.          |
| `$.`   | Specification  | Specifies or isolates a particular property of a concept.          |
| `$%`   | Abstraction    | Creates a general template from a concrete instance for reuse.     |
| `$+`   | Continuation   | Appends or adds to a concept, often used in loops to update state. |

### Timing (Sequencing) Operators

| Symbol     | Name      | Description                               |
| ---------- | --------- | ----------------------------------------- |
| `@if`      | If        | Executes if a condition is true.          |
| `@if!`     | If Not    | Executes if a condition is false.         |
| `@after`   | After     | Executes after a preceding step is complete. |

### Grouping Operators

| Symbol    | Name   | Description                                           |
| --------- | ------ | ----------------------------------------------------- |
| `&in`     | In     | Groups items contained within a larger collection.    |
| `&across` | Across | Groups items by iterating across a collection.        |

### Quantifying (Listing) Operators

| Symbol   | Name  | Description                                        |
| -------- | ----- | -------------------------------------------------- |
| `*every` | Every | Iterates over every item in a collection (a loop). |

### Concept Markers
These markers can be appended to concepts to modify their meaning.

| Symbol                | Name                 | Description                                                                 |
| --------------------- | -------------------- | --------------------------------------------------------------------------- |
| `?`                   | Conception Query     | Appended to a concept to query its value or definition. E.g., `{sum}?`. |
| `<:_number_>`         | Value Position       | To link a positional placeholder for values (e.g., `<:{1}>`, `<:{2}>`).     |
| `<$(_concept_)%_>`    | Instance Marker      | Marks a concept as an instance of an "umbrella" concept. E.g. `<$({number})%_>` |
| `<$={_number_}>`      | Identity Marker      | Identifies the same concept across different occurrences. E.g. `<$={1}>`     |
| `%:[_concept_]`       | Axis Specifier       | Specifies the `by_axis` for an operation. E.g. `%:[{number pair}]`        |
| `@(_number_)`         | Quantifier Index     | Specifies the index for a quantifier (`*every`) operation. E.g. `@(1)`       |
| `*_number_`           | Quantifier Version   | Links a concept to a specific quantifier iteration. E.g. `{number pair}*1`  |
