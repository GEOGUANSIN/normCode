### Step 4.2: Manual Review of Materialization

**Objective:** Review the final, executable scripts generated by the automated process to ensure they are correct, efficient, and ready for deployment.

**Procedure:**

1.  **Examine the Generated Scripts (e.g., `.py`, `.sh` files):**
    *   Perform a thorough code review to check for correctness, adherence to coding standards, and efficiency.
    *   Verify that the scripts accurately implement the logic defined in the NormCode plan.
    *   Manually execute the scripts in a safe, isolated test environment to confirm they run without errors and produce the expected output.

**Outcome:** A fully validated and deployment-ready set of executable scripts that fulfill the original high-level instruction.
---
# NormCode Guide - Agent's Sequences

Agent's sequences are the **operational realization** of inferences - they are the pre-defined pipelines that execute the actual logic when a functional concept invokes them. Each agent's sequence represents a specific pattern of processing steps that transform inputs into outputs.

When a functional concept (like `*every`, `::`, or `&across`) is encountered in a NormCode script, it triggers the corresponding agent's sequence, which then executes a series of standardized processing steps to realize the inference's logic.

## Available Agent's Sequences

| Sequence Name | Pattern                               | Purpose                                                       | Use Case                                                    |
|---------------|---------------------------------------|---------------------------------------------------------------|-------------------------------------------------------------|
| Simple        | `(IWI-IR-OR-OWI)`                     | Basic data retrieval and output operations                    | Usually as dummy for testing                                |
| Grouping      | `(IWI-IR-GR-OR-OWI)`                  | Handles data collection and grouping operations               | Collecting related data items using `&across` and `&in`   |
| Quantifying   | `(IWI-IR-GR-QR-OR-OWI)`               | Manages loops and iterative operations over data collections  | Iterating over collections using `*every` operator          |
| Assigning     | `(IWI-IR-AR-OR-OWI)`                  | Manages variable assignments and state updates                | Variable assignment using `$=`, `$+`, `$.`, `$%` operators   |
| Imperative    | `(IWI-IR-MFP-MVP-TVA-TIP-MIA-OR-OWI)` | Executes complex commands, often with external tools or models| Complex operations using `::` imperative operators          |
| Judgement     | `(IWI-IR-MFP-MVP-TVA-TIP-MIA-OR-OWI)` | Evaluates conditions and returns boolean-like assessments     | Conditional evaluations using `<>` judgement operators      |
| Timing        | `(IWI-T-OWI)`                         | Controls conditional execution and flow control               | Conditional logic using `@if`, `@if!`, `@after` operators |

This architecture ensures that every inference in NormCode has a well-defined operational realization through these standardized agent's sequences.
---
# NormCode Guide - Reference of Concepts

While concepts define the structure of a NormCode plan, the actual information is stored in a **Reference**. Understanding the Reference is key to grasping how data is stored, manipulated, and flows through the plan.

A Reference is the container where the information for a concept is kept. Specifically, it is the **semantical concepts** (like `{object}`, `[]`, or `<>`) that have an associated Reference, as they represent the data-holding entities within the plan.

**Key Characteristics of a Reference:**

-   **Multi-dimensional Container**: A Reference is multi-dimensional because a concept can exist in multiple contexts. Each context can introduce a new dimension, allowing the Reference to hold different instances or elements of the concept's information in a structured way.
-   **Named Axes**: Each dimension, often corresponding to a specific context, is represented as a named **axis**. This allows for clear organization and retrieval of information. For example, a concept like `{grade}` could have a Reference with axes named `student` and `assignment`, representing the different contexts in which a grade exists.
-   **Shape**: The size of each dimension defines the `shape` of the information within the Reference.
-   **Data Manipulation**: The core logic of the **Agent's Sequences** (e.g., collecting items with `grouping` or accumulating results with `quantifying`) involves manipulating the information held within these References.

In short, a `Concept` gives information its meaning within the plan, while a `Reference` provides the structure to hold and organize that information.


---
# NormCode Guide - Core Syntax

This document covers the fundamental syntax of NormCode, a semi-formal language for constructing a **plan of inferences**.

## Core Syntax: Concepts and Inferences

The fundamental unit of a Normcode plan is the **inference**. An inference is defined by a functional concept and its associated value concepts.

-   **Functional Concept (`<=`)**: This is the cornerstone of an inference. It "pins down" the inference by defining its core logic, function, or operation. Crucially, the functional concept is responsible for **invoking an agent's sequence** (e.g., `quantifying`, `imperative`), which is the underlying engine that executes the inference's logic.

-   **Value Concept (`<-`)**: This concept provides the concrete data for the inference. It specifies the inputs, outputs, parameters, or results that the functional concept operates on or produces.

The entire plan is represented in a hierarchical, vertical format. An inference begins with a root concept, followed by an indented functional concept (`<=`) that defines the operation. The value concepts (`<-`) are then supplied at the same or a more deeply nested level.

A line in Normcode can also have optional annotations for clarity and control:

`_concept_definition_ | _annotation_ // _comment_`

-   **`_concept_definition_`**: The core functional (`<=`) or value (`<-`) statement.
-   **`_annotation_`**: Optional metadata following the `|` symbol. This can be a **flow index** (e.g., `1.1.2`), an intended **data reference**, or the name of the invoked **agent's sequence**.
-   **`// _comment_`**: Human-readable comments.

**Example Structure of an Inference:**
```Normcode
_concept_to_infer_ // The overall goal of this inference
    <= _functional_concept_defining_the_operation_ | 
    quantifying // This invokes the 'quantifying' agent's sequence
    <- _input_value_concept_1_ // This is an input for the 
    operation
    <- _input_value_concept_2_
```
---
# NormCode Guide - Semantical Concepts

Concepts are the building blocks of NormCode. Semantical concepts define the core entities and logical constructs of the domain. They can be subdivided into typically non-functional and functional types.

### Typically Non-Functional Concept Types
These concepts represent entities, their relationships, or their roles in the inference.

| Symbol                | Name                      | Description                                                                 |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- |
| `{}`                  | Object                    | Represents a generic object or entity.                                      |
| `<>`                  | Statement                 | Represents a proposition or a state of affairs (non-functional).            |
| `[]`                  | Relation                  | Represents a relationship between two or more concepts.                     |
| `:S:`                 | Subject                   | Marks the subject of a relation or statement.                               |
| `:>:`                 | Input                     | A special type of Subject that marks a concept as an input parameter.       |
| `:<:`                 | Output                    | A special type of Subject that marks a concept as an output value.          |

**Examples:**
- **Object (`{}`):** `{new number pair}` declares a concept that will hold the state of the two numbers as they are processed.
- **Statement (`<>`):** `<all number is 0>` represents a condition that can be evaluated. The `judgement` agent's sequence will determine if this statement is true or false.
- **Relation (`[]`):** `[all {unit place value} of numbers]` defines a collection that will hold the digits from a specific place value of the numbers being added.

### Typically Functional Concept Types
These concepts define operations or evaluations that often initiate an inference.

| Symbol                | Name                      | Description                                                                 |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- |
| `({})` or `::()`      | Imperative                | Represents a command or an action to be executed.                           |
| `<{}>` or `<...>`     | Judgement                 | Represents an evaluation that results in a boolean-like assessment.         |

**Examples:**
- **Imperative (`::()`):** `::(get the {1}?<$({remainder})%_> of {2}<$({digit sum})%_> divided by 10)` issues a command to a tool or model to perform a calculation. This is the heart of an `imperative` inference.
- **Judgement (`<...>`):** `<= :%(True):<{1}<$({carry-over number})%_> is 0>` evaluates whether the carry-over is zero. This is the core of a `judgement` inference. Note the use of `<...>` as a common syntax variant for a judgement.
---
# NormCode Guide - Syntactical Concepts

Syntactical concepts are operators that control the logic, flow, and manipulation of data within the plan of inferences. They are grouped by their function.

### Assigning Operators

| Symbol | Name           | Description                                                        |
| ------ | -------------- | ------------------------------------------------------------------ |
| `$=`   | Identity     | Assigns a value to a concept, often used for state updates.          |
| `$.`   | Specification  | Specifies or isolates a particular property of a concept.          |
| `$%`   | Abstraction    | Creates a general template from a concrete instance for reuse.     |
| `$+`   | Continuation   | Appends or adds to a concept, often used in loops to update state. |

### Timing (Sequencing) Operators

| Symbol     | Name      | Description                               |
| ---------- | --------- | ----------------------------------------- |
| `@if`      | If        | Executes if a condition is true.          |
| `@if!`     | If Not    | Executes if a condition is false.         |
| `@after`   | After     | Executes after a preceding step is complete. |

### Grouping Operators

| Symbol    | Name   | Description                                           |
| --------- | ------ | ----------------------------------------------------- |
| `&in`     | In     | Groups items contained within a larger collection.    |
| `&across` | Across | Groups items by iterating across a collection.        |

### Quantifying (Listing) Operators

| Symbol   | Name  | Description                                        |
| -------- | ----- | -------------------------------------------------- |
| `*every` | Every | Iterates over every item in a collection (a loop). |

### Concept Markers
These markers can be appended to concepts to modify their meaning.

| Symbol                | Name                 | Description                                                                 |
| --------------------- | -------------------- | --------------------------------------------------------------------------- |
| `?`                   | Conception Query     | Appended to a concept to query its value or definition. E.g., `{sum}?`. |
| `<:_number_>`         | Value Position       | To link a positional placeholder for values (e.g., `<:{1}>`, `<:{2}>`).     |
| `<$(_concept_)%_>`    | Instance Marker      | Marks a concept as an instance of an "umbrella" concept. E.g. `<$({number})%_>` |
| `<$={_number_}>`      | Identity Marker      | Identifies the same concept across different occurrences. E.g. `<$={1}>`     |
| `%:[_concept_]`       | Axis Specifier       | Specifies the `by_axis` for an operation. E.g. `%:[{number pair}]`        |
| `@(_number_)`         | Quantifier Index     | Specifies the index for a quantifier (`*every`) operation. E.g. `@(1)`       |
| `*_number_`           | Quantifier Version   | Links a concept to a specific quantifier iteration. E.g. `{number pair}*1`  |
