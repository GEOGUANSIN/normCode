# Step 4.2: Automated Prompt Generation

**Objective:** To assemble the final, executable prompt files by combining the specific context required for each prompt-driven inference. This is a deterministic assembly step, not an LLM generation step.

**Process:**

This step is an automated script that takes one key input:

1.  **The final Context Manifest (`4.1_context_manifest.json`):** This file provides the complete mapping between each prompt and its required context files.

The script performs the following actions:

1.  **Reads the Manifest:** It parses the `4.1_context_manifest.json` file.
2.  **Iterates Through Prompts:** It loops through each key-value pair in the `context_mapping` object. Each key represents a unique prompt file to be generated.
3.  **Assembles Content:** For each prompt, it reads the array of file paths from the `context_files` field. It then opens and concatenates the content of each of these files in the specified order. The general convention is to list shared context files first, followed by more specific, step-related files.
4.  **Writes Prompt Files:** The concatenated content is written to a new file within the `prompts/` directory. The name of the file is taken directly from the key in the manifest (e.g., `[1.2.2.2.]1.1_instruction_distillation.md`).

---

### Example Walkthrough

This example demonstrates how a single prompt file is assembled.

**1. Input (`4.1_context_manifest.json` snippet):**

The manifest provides the "recipe" for building the prompt.

```json
{
  "context_mapping": {
    "[1.2.2.2.]1.1_instruction_distillation.md": {
      "used_by_inference": "1.2.2.1.imperative|<= ::{%(direct)}(...)",
      "context_files": [
        "./context_store/shared---pipeline_goal_and_structure.md",
        "./context_store/1.2.2.1---automated_instruction_distillation.md"
      ]
    },
    // ... other prompt mappings
  }
}
```

**2. Assembly Process:**

The script identifies the entry for `[1.2.2.2.]1.1_instruction_distillation.md`. It then:
1.  Reads the content of `./context_store/shared---pipeline_goal_and_structure.md`.
2.  Reads the content of `./context_store/1.2.2.1---automated_instruction_distillation.md`.
3.  Concatenates these two pieces of content together.
4.  Creates a new file named `prompts/[1.2.2.2.]1.1_instruction_distillation.md`.
5.  Writes the concatenated content into this new file.

**3. Output (A new file in `prompts/`):**

The result is a complete, self-contained prompt file ready to be used by the corresponding imperative (`1.2.2.1.imperative`). The content of `prompts/[1.2.2.2.]1.1_instruction_distillation.md` would look like this:

```markdown
<Content of shared---pipeline_goal_and_structure.md>
---
<Content of 1.2.2.1---automated_instruction_distillation.md>
```

This process is repeated for every entry in the manifest, resulting in a fully populated `prompts/` directory.
