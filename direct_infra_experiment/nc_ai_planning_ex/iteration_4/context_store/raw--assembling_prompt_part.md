# Serialization and Redirection of the Plan - Prompt Part Assembling

This document summarizes the systematic proces to transform a high-level meta-pipeline prompt into a structured, formal, and context-aware plan. The process involved several key transformations, each building upon the last to add detail and formality.

## 1. Serialization (`4.1_serialized.ncd`)

The initial phase focused on cleaning up the raw plan and giving it a consistent structure.

-   **Cleanup**: Removed all informal notation lines (`/:`, `?:`, `...:`).
-   **Serialization**: The core pattern applied was to reframe each step as an *output* being generated by an *imperative*. This established a clear "effect <= cause" relationship throughout the plan.

For example, a step was structured as:

```normcode
<- {output_file.ext}
    <= ::(imperative describing the action)
```

This created a foundation where each generated artifact was explicitly linked to the action that created it.

## 2. Redirection (`4.2_redirected.ncd`)

This step was crucial for making the data flow of the pipeline explicit. The goal was to define the precise inputs for every imperative.

-   **Explicit Inputs**: Each imperative was detailed to show its dependencies, which were categorized as:
    -   **Prompts**: Inputs sourced from a prompt file, identified with a `<:{prompt}>` tag and a `%{prompt_location}` annotation.
    -   **Inherited Outputs**: Inputs that were the direct result of a previous step in the pipeline.
    -   **File Inputs**: Inputs sourced directly from files on disk.

An example of a redirected imperative:

```normcode
<- {1.1_instruction_block.md}
    <= ::{%(direct)}({prompt}<$({instruction distillation prompt})%>: {1}<$({ipnut files})%>)
    <- {instruction distillation prompt}<:{prompt}>
        |%{prompt_location}: instruction_distillation_prompt.md
    <- {input files}<:{1}>
        <= &in
        <- {original prompt}
```

This process made the plan's dependencies transparent and prepared it for formalization.

## 3. Formalization (`4.3_redirected.nc`)

The redirected draft (`.ncd`) was converted into a formal, machine-readable NormCode script (`.nc`).

-   **Annotation Stripping**: All informal comments and annotations were removed.
-   **Flow Indexing**: Each line was assigned a unique, hierarchical `flow_index` (e.g., `1.2.2.1`). This provides a precise address for every element in the plan.
-   **Agent Sequence Typing**: Each line was categorized with a type (e.g., `object`, `imperative`, `grouping`) to define its role.
-   **Annotation Embedding**: A key refinement was embedding the `%{prompt_location}` annotation directly into the flow index of the corresponding prompt object, creating a permanent link between the prompt's formal representation and its source file.

Example of a formalized prompt object:

```normcode
1.2.2.2.object_%{prompt_location}:instruction_distillation_prompt.md|<- {instruction distillation prompt}<:{prompt}>
```

## 4. Context Mapping (`4.4._context_manifest_redirected copy.json`)

Initially, we created a context manifest that mapped context files to the **imperatives** that would use them.

-   **Imperative-keyed Map**: The keys in this JSON file were the full imperative lines from `4.3_redirected.nc`.
-   **Context Files**: The values were arrays of file paths pointing to the necessary context documents in the `context_store/`.

```json
"1.2.2.1.imperative|<= ::{%(direct)}({prompt}<$({instruction distillation prompt})%>: {1}<$({ipnut files})%>)": [
    "./context_store/1.3.2.2---automated_instruction_distillation.md",
    "./context_store/shared---pipeline_goal_and_structure.md"
]
```

## 5. Refined Context Mapping for Prompts (`4.5._context_for_prompt.json`)

We then refined the context mapping to associate context directly with the **prompts** themselves, which is a more logical and direct relationship. This led to the final context manifest used for prompt generation.

-   **Prompt-keyed Map**: The keys were changed to uniquely identify the prompts.
-   **Key Format**: The final format for the keys combines the prompt's flow index and its filename, creating a unique and descriptive identifier: `"[flow_index]prompt_filename.md"`.

```json
"[1.2.2.2.]instruction_distillation_prompt.md": [
    "./context_store/1.3.2.2---automated_instruction_distillation.md",
    "./context_store/shared---pipeline_goal_and_structure.md"
]
```

This final manifest was then used to successfully generate all the prompt files in the `prompts/` directory, completing the transformation of the meta-pipeline into an executable set of context-aware instructions.
