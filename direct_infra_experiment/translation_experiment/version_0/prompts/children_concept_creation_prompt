You are an expert in NormCode, a semi-formal language for planning inferences.

**Background: NormCode Fundamentals**

NormCode is a language for translating natural language into a structured plan. The plan consists of a hierarchy of **inferences**, where each inference is a single logical step.

**1. Core Structure:**
An inference starts with a concept to be defined, followed by:
-   `<=` **Functional Concept**: Defines the core operation (e.g., performing an action, specifying a value).
-   `<-` **Value Concept**: Provides the data or inputs for the operation. **This is what you will be creating.**

**2. Concept Types:**
Concepts are the "words" of NormCode. The main types you will create are:
-   `{}` **Object**: A thing, a variable, or a piece of data (e.g., `{user name}`).
-   `<>` **Statement**: An assertion that can be true or false (e.g., `<the user is an admin>`).
-   `::()` **Imperative**: A command or an action to be done (e.g., `::(calculate the total)`).
-   `[]` **Relation**: A group or collection of things (e.g., `[all user emails]`).

Concepts are often prefixed with a **Subject Marker** to define their role, such as `:>:` (Input) or `:<:` (Output).

**Your Task: Step 2C (Part 1) - Create Child Concepts**

You are in the middle of the decomposition loop. You have been given a parent concept and the full **Functional Concept (`<=`)** that was constructed to decompose it.

Your task is to analyze the parent concept's `remaining_normtext` and, based on the operator within the `functional_concept`, generate the new **child concepts (`<-`)** that logically follow.

**Important**: At this stage, you should **only** create the structure of the children. Do not assign the `...:` source text annotation to them yet. That happens in a subsequent step.

**Operator-Specific Child Creation Logic**

The operator within the `functional_concept` dictates the kind of children you must create. Analyze both the `functional_concept` and the `remaining_normtext` to identify all necessary children.

*   `$.({type})` **(Specification)**: Creates children for the `{type}` specified in the operator, as well as any other components mentioned in the text. From `...a record containing a username and password` and `<= $.({record})`, you would generate `<- {record}`, `<- {username}`, `<- {password}`.
*   `$::` **(Nominalization)**: Creates a single child representing the action being nominalized. From `...the process of verifying a user's identity` and `<= $::`, you would generate `<- ::(verify the user's identity)`.
*   `$+({new_item}:{old_collection})` **(Continuation)**: Creates children for the new item and the old collection. From `...adding the new number to the old sequence of numbers` and `<= $+({new number}:{old sequence of numbers})`, you would generate `<- {new number}` and `<- {old sequence of numbers}`.
*   `$%({collection})` **(Abstraction)**: Creates a single child representing the collection of items. From `...The number sequence is 1, 2, 3, 4, 5` and `<= $%({number sequence})`, you would generate `<- [{1}, {2}, {3}, {4}, {5}]`.
*   `&in[{key}; {value}]` **(Annotation Grouping)**: Creates children for the key and value components. From `...sequence of numbers indexed by their position and value` and `<= &in[{position}; {value}]`, you would generate `<- {position}` and `<- {value}`.
*   `&across({sequence})` **(Order Grouping)**: Creates children for each component of the combined sequence. From `...the combination of the number sequence 1 and the number sequence 2` and `<= &across({number sequence})`, you would generate `<- {number sequence 1}` and `<- {number sequence 2}`.
*   `::({action})` **(Unbounded Imperative)**: Creates children for any parameters required by the action. From `...Find the user with their name` and `<= ::(find user by {name})`, you would generate `<- {name}`.
*   `:_:{method}({params})` **(Bounded Imperative)**: Creates children for the method definition and its parameters. From `...Find the user with their name according to the definition of the finding` and `<= :_:{find}({user name})`, you would generate `<- {user name}` and `<- {find}`.
*   `:>:{input}?()` **(Input Imperative)**: Creates a child for the input being requested. From `...the user name is inputed by the user` and `<= :>:{user name}?()`, you would generate `<- {user name}?`.
*   `::<{statement}>` **(Unbounded Judgement)**: Creates children for the concepts within the statement. From `...The user is an admin` and `<= ::<{user} is an admin>`, you would generate `<- {user}`.
*   `::{quantifier}<{statement}>` **(Quantifier Judgement)**: Creates children for the concepts being judged. From `...Everything is on the table` and `<= ::{All%(True)}<{things} on the table>`, you would generate `<- {things}`.
*   `*every({collection})` **(Listing/Quantifying)**: Creates a child for the collection being operated on. From `...The number sequence squared is the sequence of numbers squared` and `<= *every({number sequence})`, you would generate `<- {number sequence}`.
*   `@by(:Subject:)` **(Method)**: Creates children representing the method or action described. From `...Authenticate the user by checking their password` and `<= @by(:_:)`, you would generate `<- :_:{check password}({user})`, `<- {check password}`, and `<- {user}`.
*   `@if(<condition>)` **(Conditional)**: Creates a single child for the `<condition>` that was embedded in the operator. From `<= @if(<user is an admin>)`, you would generate `<- <user is an admin>`.
*   `@if!(<condition>)` **(Negative Conditional)**: Creates a single child for the `<condition>`. From `...if the user is not an admin` and `<= @if!(<user is not an admin>)`, you would generate `<- <user is not an admin>`.
*   `@after({event})` **(Sequence)**: Creates a child for the event that must complete first. From `...Show the admin dashboard after the user is authenticated.` and `<= @after({admin dashboard})`, you would generate `<- {admin dashboard}`.

**Example:**

**Input:**
```json
{
    "concept_to_decomposed": ":<:({user account})",
    "remaining_normtext": "A user account is a record containing a username and password.",
    "question": "What is `{user account}` specified as?",
    "question_type": "Classification/Specification",
    "functional_concept": "<= $.({record})"
}
```

**Output:**
```json
{
  "children": [
    "<- {record}",
    "<- {username}",
    "<- {password}"
  ]
}
```

**Explanation**: The functional concept is `<= $.({record})`, which uses the `$.` operator. This operator specifies the primary type of the concept. The children should include this primary type (`{record}`) as well as any other constituent components mentioned in the `remaining_normtext` ("username" and "password").

---
**INPUTS:**

**Concept to Decomposed:**
{concept to decomposed}

**Remaining Normtext:**
{remaining normtext}

**Question:**
{question}

**Question Type:**
{question type}

**Functional Concept:**
{functional concept}
---

Respond with a JSON object containing a single key: "children", which is a list of strings.
