You are an expert in NormCode, a semi-formal language for planning inferences.

**Background: NormCode Fundamentals**

NormCode translates natural language into a structured plan of **inferences**.
-   **Core Structure**: Inferences use `<=` for functional concepts (operations) and `<-` for value concepts (data).
-   **Semantical Concepts**: These are the "words," like `{Object}`, `<Statement>`, and `::(Imperative)`.
-   **Annotations**: `...:` holds the source text to be analyzed. A concept with a `...:` is "un-decomposed."

**Your Task: Step 2C (Part 2) - Generate Full Inference**

You have been given the `concept_to_decomposed`, its `functional_concept` (`<=`), a set of new `child_concepts` (`<-`), and the parent's `source_text` (`...:`). Your task is to generate the **complete, annotated inference**.

This involves deciding for **both** the functional concept and all child concepts whether they are **definitive** (`/:`) or require **further decomposition** (`...:`).

1.  `...:` **(Source Text)**: Assign a snippet of the parent's text. This signifies the concept is **not fully resolved** and requires another decomposition loop.
2.  `/:` **(Description)**: Assign a concise description. This signifies the concept is **definitive** in the current context.

Your final output must be a single JSON object.

First, think step-by-step about how to distribute the source text and assign annotations. Place your reasoning in the "analysis" key of the JSON object.
Then, provide the final answer in the "answer" key as a dictionary containing:
- "new inference": The complete, annotated inference as a single string, with proper indentation and newline characters (`\n`)

**Guiding Principles for Annotation**

1.  **Functional Concept (`<=`)**:
    *   Assign `...:` if the parent text contains conditions or clauses that apply to the operation itself. (e.g., `"...if the feeling is mutual"`).
    *   Assign `/:` if the operation is straightforward and fully described by its children (the common case).

2.  **Child Concepts (`<-`)**:
    *   Assign `/:` (making it **definitive**) for I/O operations, self-contained concepts (like a nominalized action), or pre-defined concepts.
    *   Assign `...:` if the child is complex and has its own descriptive text within the parent's source that needs to be broken down further.

**Examples**

**Example 1: Definitive Child and Functional Description**

**Input:**
```json
{
    "concept to decomposed": ":<:({User Authentication})",
    "functional concept": "<= $::",
    "child concepts": [
        "<- ::(verify the user's identity)"
    ],
    "parent source text": "User authentication is the process of verifying a user's identity."
}
```

**Output:**
```json
{
  "analysis": "I need to analyze the parent source text 'User authentication is the process of verifying a user's identity.' The functional concept is `<= $::` (nominalization), and there's one child concept `<- ::(verify the user's identity)`. The parent text fully explains the nominalization without adding any conditions or clauses that need further decomposition. Therefore, both the functional concept and child concept should be assigned `/:` (definitive descriptions). The functional concept gets a description explaining it's a process, and the child gets a description of the action.",
  "answer": {
    "new inference": ":<:({User Authentication})\n    <= $::\n        /: It is defined as a process.\n    <- ::(verify the user's identity)\n        /: The action is to verify a user's identity."
  }
}
```

**Explanation**: The output follows the required JSON structure with `analysis` containing the reasoning and `answer` containing a dictionary with the complete inference.

**Example 2: Functional Source Text (`...:`)**

**Input:**
```json
{
    "concept to decomposed": ":<:({love})",
    "functional concept": "<= $.({deep feeling})",
    "child concepts": [
        "<- {deep feeling}"
    ],
    "parent source text": "love is a deep feeling, (if) the feeling is mutual."
}
```

**Output:**
```json
{
  "analysis": "I need to analyze the parent source text 'love is a deep feeling, (if) the feeling is mutual.' The functional concept is `<= $.({deep feeling})` (specification), and there's one child concept `<- {deep feeling}`. The parent text contains a conditional clause 'if the feeling is mutual' that applies to the operation itself (the specification is conditional). According to the guiding principles, when the parent text contains conditions that apply to the operation, I should assign `...:` to the functional concept. The child `{deep feeling}` is straightforward and should get a definitive description (`/:`).",
  "answer": {
    "new inference": ":<:({love})\n    <= $.({deep feeling})\n        ...: if the feeling is mutual.\n    <- {deep feeling}\n        /: love is a deep feeling."
  }
}
```

**Explanation**: The output follows the required JSON structure with `analysis` containing the reasoning and `answer` containing a dictionary with the complete inference.

---
**INPUTS:**

**Concept to Decomposed:**
$input_1

**Functional Concept (`<=`):**
$input_2

**Child Concepts (a list of strings):**
$input_3

**Parent's `...:` text to distribute:**
$input_4
---

Execute the instruction and return a JSON object with "analysis" (your reasoning) and "answer" (a dictionary with "new inference"). Return only the JSON object.
