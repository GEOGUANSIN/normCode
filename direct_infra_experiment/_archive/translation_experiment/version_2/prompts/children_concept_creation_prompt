You are an expert in NormCode, a semi-formal language for planning inferences.

**Background: NormCode Fundamentals**

NormCode is a language for translating natural language into a structured plan. The plan consists of a hierarchy of **inferences**, where each inference is a single logical step.

**1. Core Structure:**
An inference starts with a concept to be defined, followed by:
-   `<=` **Functional Concept**: Defines the core operation (e.g., performing an action, specifying a value).
-   `<-` **Value Concept**: Provides the data or inputs for the operation. **This is what you will be creating.**

**2. Concept Types:**
Concepts are the "words" of NormCode. The main types you will create are:
-   `{}` **Object**: A thing, a variable, or a piece of data (e.g., `{user name}`).
-   `<>` **Statement**: An assertion that can be true or false (e.g., `<the user is an admin>`).
-   `::()` **Imperative**: A command or an action to be done (e.g., `::(calculate the total)`).
-   `[]` **Relation**: A group or collection of things (e.g., `[all user emails]`).

Concepts are often prefixed with a **Subject Marker** to define their role, such as `:>:` (Input) or `:<:` (Output).

**Your Task: Step 2C (Part 1) - Create Child Concepts**

You are in the middle of the decomposition loop. You have been given a parent concept and the full **Functional Concept (`<=`)** that was constructed to decompose it.

Your task is to analyze the parent concept's `remaining_normtext` and, based on the operator within the `functional_concept`, generate the new **child concepts (`<-`)** that logically follow.

**Important**: At this stage, you should **only** create the structure of the children. Do not assign the `...:` source text annotation to them yet. That happens in a subsequent step.

**Guiding Principles for Hierarchical Purity**
To maintain a clean and logical hierarchy, follow these two principles:

1.  **One Action/Judgement per Step**: A decomposition should generally result in **only one** primary action (`::()`) or judgement (`<>`) child. Avoid creating multiple sibling actions. This rule does not apply to operators like `@by(:_:)` and `$::`, which have specific structural requirements.
2.  **No Nested Actions Within a Definition**: If the `functional_concept` (the `<=` line) is itself an imperative or a judgement, its direct children (`<-` lines) must **not** be other imperatives or judgements. They should only be the parameters or components of that top-level action (e.g., `{Objects}`, `<Statements>`).

Your final output must be a single JSON object.

First, think step-by-step about how to create the child concepts based on the operator and source text. Place your reasoning in the "analysis" key of the JSON object.
Then, provide the final answer in the "answer" key as a dictionary containing:
- "children": A list of strings, where each string is a child concept formatted with the `<-` prefix

**Sources of Child Concepts**

Child concepts can be derived from two primary sources. You must analyze the functional concept to determine which source to use.

1.  **Extracted Directly from the Functional Concept**: For operators like `@if(<condition>)` or `@after({event})`, the child concept is explicitly provided within the operator. Your task is simply to extract it and format it as a `<-` concept.
2.  **Parsed from the Remaining Normtext**: For operators like `$.`, `::()`, or `@by`, the operator provides a template or a guide. You must analyze the `remaining_normtext` to identify and create the specific child concepts that fit that template. This often involves creating multiple children.

**Operator-Specific Child Creation Logic**

The operator within the `functional_concept` dictates the kind of children you must create. Analyze both the `functional_concept` and the `remaining_normtext` to identify all necessary children.

*   `$.({type})` **(Specification)**: Creates children for the `{type}` specified in the operator, as well as any other components mentioned in the text. From `...a record containing a username and password` and `<= $.({record})`, you would generate `<- {record}`, `<- {username}`, `<- {password}`.
*   `$::` **(Nominalization)**: Creates a single child representing the action being nominalized. From `...the process of verifying a user's identity` and `<= $::`, you would generate `<- ::(verify the user's identity)`.
*   `$+({new_item}:{old_collection})` **(Continuation)**: Creates children for the new item and the old collection. From `...adding the new number to the old sequence of numbers` and `<= $+({new number}:{old sequence of numbers})`, you would generate `<- {new number}` and `<- {old sequence of numbers}`.
*   `$%({collection})` **(Abstraction)**: Creates a single child representing the collection of items. From `...The number sequence is 1, 2, 3, 4, 5` and `<= $%({number sequence})`, you would generate `<- [{1}, {2}, {3}, {4}, {5}]`.
*   `&in[{key}; {value}]` **(Annotation Grouping)**: Creates children for the key and value components. From `...sequence of numbers indexed by their position and value` and `<= &in[{position}; {value}]`, you would generate `<- {position}` and `<- {value}`.
*   `&across({sequence})` **(Order Grouping)**: Creates children for each component of the combined sequence. From `...the combination of the number sequence 1 and the number sequence 2` and `<= &across({number sequence})`, you would generate `<- {number sequence 1}` and `<- {number sequence 2}`.
*   `::({action})` **(Unbounded Imperative)**: Creates children for any parameters required by the action. From `...Find the user with their name` and `<= ::(find user by {name})`, you would generate `<- {name}`.
*   `:_:{method}({params})` **(Bounded Imperative)**: Creates children for the method definition and its parameters. From `...Find the user with their name according to the definition of the finding` and `<= :_:{find}({user name})`, you would generate `<- {user name}` and `<- {find}`.
*   `:>:{input}?()` **(Input Imperative)**: Creates a child for the input being requested. From `...the user name is inputed by the user` and `<= :>:{user name}?()`, you would generate `<- {user name}?`.
*   `::<{statement}>` **(Unbounded Judgement)**: Creates children for the concepts within the statement. From `...The user is an admin` and `<= ::<{user} is an admin>`, you would generate `<- {user}`.
*   `::{quantifier}<{statement}>` **(Quantifier Judgement)**: Creates children for the concepts being judged. From `...Everything is on the table` and `<= ::{All%(True)}<{things} on the table>`, you would generate `<- {things}`.
*   `*every({collection})` **(Listing/Quantifying)**: Creates a child for the collection being operated on. From `...The number sequence squared is the sequence of numbers squared` and `<= *every({number sequence})`, you would generate `<- {number sequence}`.
*   `@by(:Subject:)` **(Method)**: Creates children representing the method or action described. From `...Authenticate the user by checking their password` and `<= @by(:_:)`, you would generate `<- :_:{check password}({user})`, `<- {check password}`, and `<- {user}`.
*   `@if(<condition>)` **(Conditional)**: Creates a single child for the `<condition>` that was embedded in the operator. From `<= @if(<user is an admin>)`, you would generate `<- <user is an admin>`.
*   `@if!(<condition>)` **(Negative Conditional)**: Creates a single child for the `<condition>`. From `...if the user is not an admin` and `<= @if!(<user is not an admin>)`, you would generate `<- <user is not an admin>`.
*   `@after({event})` **(Sequence)**: Creates a child for the event that must complete first. From `...Show the admin dashboard after the user is authenticated.` and `<= @after({admin dashboard})`, you would generate `<- {admin dashboard}`.

**Example 1: Specification (`$.`)**

**Input:**
```json
{
    "concept to decomposed": ":<:({user account})",
    "remaining normtext": "A user account is a record containing a username and password.",
    "question": "What is `{user account}` specified as?",
    "question type": "Classification/Specification",
    "functional concept": "<= $.({record})"
}
```

**Output:**
```json
{
  "analysis": "The functional concept is `<= $.({record})`, which uses the `$.` operator for Classification/Specification. This operator specifies the primary type of the concept. According to the operator-specific logic, I need to create children for the `{type}` specified in the operator (which is `{record}`) as well as any other components mentioned in the remaining normtext. The text mentions 'a record containing a username and password', so I should create: `<- {record}` (the primary type), `<- {username}`, and `<- {password}` (the constituent components). This adheres to the guiding principles as the functional concept is not an action, and none of the children are new actions or judgements.",
  "answer": {
    "children": [
      "<- {record}",
      "<- {username}",
      "<- {password}"
    ]
  }
}
```

**Example 2: Complex Methodology (`@by`)**

**Input:**
```json
{
    "concept to decomposed": ":<:(::(Authenticate the user))",
    "remaining normtext": "Authenticate the user by checking their password.",
    "question": "How do you authenticate the user?",
    "question type": "Methodology Declaration",
    "functional concept": "<= @by(:_:)"
}
```

**Output:**
```json
{
  "analysis": "The functional concept is `<= @by(:_:)`, which uses the `@by` operator for Methodology Declaration. This operator signifies that the action is performed by a specific method. The `remaining_normtext` is 'Authenticate the user by checking their password'. I need to parse this to define the method. The method is 'checking their password', which can be represented as a bounded imperative `:_:{check password}({user})`. According to the operator logic, I must create children for the bounded imperative itself, as well as its components. Therefore, the children are `<- :_:{check password}({user})`, `<- {check password}`, and `<- {user}`. This follows the guiding principles, as `@by` is an explicit exception that is designed to introduce the single, primary method for an action.",
  "answer": {
    "children": [
      "<- :_:{check password}({user})",
      "<- {check password}",
      "<- {user}"
    ]
  }
}
```

**Example 3: Simple Conditional (`@if`)**

**Input:**
```json
{
    "concept to decomposed": ":<:(::(Show the admin dashboard))",
    "remaining normtext": "Show the admin dashboard if the user is an admin.",
    "question": "When do you show the admin dashboard?",
    "question type": "Conditional Dependency",
    "functional concept": "<= @if(<user is an admin>)"
}
```

**Output:**
```json
{
  "analysis": "The functional concept is `<= @if(<user is an admin>)`. This uses the `@if` operator, which introduces a conditional dependency. The operator-specific logic states that for `@if(<condition>)`, the child is the `<condition>` itself. In this case, the condition `<user is an admin>` is provided directly in the functional concept. Therefore, my only task is to extract this concept and format it as a child. No parsing of the `remaining_normtext` is needed for this operator. This adheres to the guiding principles by creating a single judgement child (`<user is an admin>`) which serves as a parameter for the conditional operator.",
  "answer": {
    "children": [
      "<- <user is an admin>"
    ]
  }
}
```

**Explanation**: The output follows the required JSON structure with `analysis` containing the reasoning and `answer` containing a dictionary with the children list.

---
**INPUTS:**

**Concept to Decomposed:**
$input_1

**Remaining Normtext:**
$input_2

**Question:**
$input_3

**Question Type:**
$input_4

**Functional Concept:**
$input_5
---

Execute the instruction and return a JSON object with "analysis" (your reasoning) and "answer" (a dictionary with "children"). Return only the JSON object.
