You are an expert in NormCode, a semi-formal language for planning inferences.

**Background: NormCode Fundamentals**

NormCode is a language for translating natural language into a structured plan. The plan consists of a hierarchy of **inferences**, where each inference is a single logical step.

**1. Core Structure:**
An inference starts with a concept to be defined, followed by:
-   `<=` **Functional Concept**: Defines the core operation (e.g., performing an action, specifying a value).
-   `<-` **Value Concept**: Provides the data or inputs for the operation.

**2. Concept Types:**
Concepts are the "words" of NormCode. The main types are:
-   `{}` **Object**: A thing, a variable, or a piece of data (e.g., `{user name}`).
-   `<>` **Statement**: An assertion that can be true or false (e.g., `<the user is an admin>`).
-   `::()` **Imperative**: A command or an action to be done (e.g., `::(calculate the total)`).
-   `[]` **Relation**: A group or collection of things (e.g., `[all user emails]`).

Concepts are often prefixed with a **Subject Marker** to define their role, such as `:>:` (Input) or `:<:` (Output).

**3. Annotations:**
Annotations manage the state of the translation process:
-   `...:` **Source Text**: Holds the piece of the original natural language (`normtext`) currently being analyzed. **A concept with a `...:` annotation is considered "un-decomposed."**
-   `?:` **Question**: The question being asked about the source text.
-   `/:` **Description**: A human-readable summary of the result of the decomposition.

**Your Task: Step 2B - Construct the Functional Concept**

You have been given a parent concept, a specific question, its type, and the relevant source text. Your task is to analyze the `remaining_normtext` and **construct the complete, substantive Functional Concept line** (`<= ...`) that answers the question.

Your final output must be a single JSON object.

First, think step-by-step about how to construct the functional concept based on the question type and source text. Place your reasoning in the "analysis" key of the JSON object.
Then, provide the final answer in the "answer" key as a dictionary containing:
- "functional concept": The complete functional concept line starting with `<= `

**Operator Construction Reference**

Use the `question_type` as a key to find the correct operator pattern and construction logic.

***

**A. Operators for Object-Like Concepts**

| Question Type                  | Operator Pattern        | Construction Logic                                                                                                                         |
| ------------------------------ | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Classification/Specification** | `$.({type})`            | From the text, identify the primary type or class the concept belongs to. Construct the operator with that type. E.g., from "...is a **record**...", create `$.({record})`. |
| **Nominalization**             | `$::`                   | This operator typically stands alone. It transforms the parent concept (an action-as-a-noun) into a formal process.                            |
| **Continuation/Extension**     | `$+(...)`               | Identify concepts being added/extended. E.g., `...adding {new number} to {old sequence}` → `$+({new number}:{old sequence})`.                 |
| **Instantiation**              | `$%`                    | This operator typically stands alone. The specific instances will be created as children.                                                   |
| **Identification**             | `$={marker}`            | Identify the marker or tag the concept is identical to. E.g., `...marked by {1}` → `$={1}`.                                               |
| **Annotated Composition**      | `&in[...]`              | Identify the fields of the structure. E.g., `...indexed by {position} and {value}` → `&in[{position}; {value}]`.                          |
| **Ordered Composition**        | `&across`               | This operator typically stands alone. The ordered items will be created as children.                                                       |
| **Process Request (Unbounded)** | `::(action)`            | Extract the complete imperative action from the text when it's defined inline. E.g., `...find the user with their name` → `::(find user by {name})`. |
| **Process Request (Bounded)**   | `:_:{method}({params})` | Extract the pre-defined method and its parameters. E.g., `...Find the user...according to the definition of the finding` → `:_:{find}({user name})`. |
| **I/O Request (Input)**         | `:>:({concept})?()`     | Extract the concept being input. E.g., `...input the {user name}` → `:>:{user name}?()`.                                                     |
| **I/O Request (Output)**        | `:<:({concept})`        | Extract the concept being output. E.g., `...output the {user name}` → `:<:({user name})`.                                                    |
| **Judgement Request (Unbounded)** | `::<statement>`         | Extract the complete simple statement to be judged. E.g., `...if the user is an admin` → `::<user is an admin>`.                            |
| **Judgement Request (Quantifier)**| `::{quantifier}<statement>` | Extract the quantifier and the statement. E.g., `...Everything is on the table` → `::{All%(True)}<{things} on the table>`.              |
| **Element-wise Breakdown**     | `*every({collection})`  | Identify the collection being operated on. E.g., `...each of the {number sequence}` → `*every({collection})`.                          |

***

**B. Operators for Action-Like Concepts**

| Question Type              | Operator Pattern      | Construction Logic                                                                                                                      |
| -------------------------- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **Methodology Declaration**  | `@by(:Subject:)`      | Identify the method described in the text. The `:Subject:` should be the subject marker of the method concept (e.g., `:_:`, `::`, `:>:`) that will be defined as a child. E.g., from `...by checking their password` (a bounded process), create `@by(:_:)`. |
| **Conditional Dependency** | `@if(<condition>)`    | Extract the condition that gates the action. E.g., `...if <user is an admin>` → `@if(<user is an admin>)`.                                |
| **Sequential Dependency**  | `@after({event})`     | Extract the event/action that must complete first. E.g., `...after {user is authenticated}` → `@after(::(authenticate user))`.             |

***

**Example:**

Input:
```json
{
    "concept to decomposed": ":<:(::(Show the admin dashboard))",
    "remaining normtext": "...: Show the admin dashboard if the user is an admin.",
    "question": "Under what condition is `::(Show the admin dashboard)` executed?",
    "question type": "Conditional Dependency"
}
```

Output:
```json
{
  "analysis": "The question type is 'Conditional Dependency', which requires using the `@if` operator pattern. I need to extract the condition from the remaining normtext 'Show the admin dashboard if the user is an admin.' The condition is 'if the user is an admin', which should be formatted as `<user is an admin>` (a statement). The complete functional concept line should be `<= @if(<user is an admin>)`.",
  "answer": {
    "functional concept": "<= @if(<user is an admin>)"
  }
}
```
**Explanation**: The output follows the required JSON structure with `analysis` containing the reasoning and `answer` containing a dictionary with the functional concept.

**Input for this task:**
---
**Concept to Decomposed**: 
$input_1
---
**Remaining Normtext**: 
$input_2
---
**Question**: 
$input_3
---
**Question Type**: 
$input_4
---

Execute the instruction and return a JSON object with "analysis" (your reasoning) and "answer" (a dictionary with "functional concept"). Return only the JSON object.
