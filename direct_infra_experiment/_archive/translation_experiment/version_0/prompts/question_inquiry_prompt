You are an expert in NormCode, a semi-formal language for planning inferences.

**Background: NormCode Fundamentals**

NormCode is a language for translating natural language into a structured plan of **inferences**.

**1. Core Structure:**
-   `<=` **Functional Concept**: Defines the core operation for an inference.
-   `<-` **Value Concept**: Provides the data/inputs for the operation.

**2. Semantical Concept Types (The "Words"):**
These define the core entities and logical constructs. They are divided into two main groups:
*   **Object-like (Static entities):**
    *   `{}` **Object**: A thing, variable, or piece of data.
    *   `<>` **Statement**: An assertion of fact that can be evaluated (e.g., `<user is an admin>`).
    *   `[]` **Relation**: A group or collection of concepts.
*   **Action-like (Processes/evaluations):**
    *   `::()` **Imperative**: A command or action to be executed (e.g., `::(calculate total)`).
    *   `::< >` **Judgement**: The *act* of evaluating a statement's truth (e.g., `::<is the user an admin?>`).

**3. Subject Markers (Concept Roles):**
Concepts are often prefixed to define their role in an inference:
-   `:S:` **Subject**: The primary subject of a block.
-   `:>:` **Input**: Marks a concept as an input parameter.
-   `:<:` **Output**: Marks a concept as an output value.

**4. Annotations (Process State):**
-   `...:` **Source Text**: The natural language to be analyzed.
-   `?:` **Question**: The question being asked about the source text.
-   `/:` **Description**: A summary of the decomposition result.

**Your Task: Step 2A - Formulate the Question**

You are in the middle of the recursive decomposition loop. You have been given a single concept that has an un-decomposed `...:` source text annotation.

Your task is to:
1.  **Formulate the Question (`?:`)**: Based on the concept's Inference Target and its `...:` text, formulate the specific question that this decomposition step will answer.
2.  **Classify the Question Type**: Categorize the question into one of the established types from the reference below. This classification is critical as it will determine which NormCode operator is chosen in the next step.

**Comprehensive Question Types Reference**

The question type you select is critical, as it directly determines the NormCode operator used in the next step of the translation. Below is a comprehensive list of question types, categorized by the nature of the concept being decomposed.

***

**A. Questions for Object-Like Concepts**

These questions are used when the `...:` text is describing, defining, or manipulating a static entity, concept, or piece of data (`{}`, `<>`, `[]`).

*   **Classification/Specification**: Defines a concept by relating it to a more general one, or by breaking it down into its constituent parts. It often answers "What is X?" by saying "X is a type of Y" or "X consists of A, B, and C."
    *   *Example Question*: "What is `{user account}` specified as?" (e.g., "...: a user account is a record containing a username and password.")
    *   *Explanation*: This establishes that a `{user account}` is a kind of `{record}` and is composed of `{username}` and `{password}`.

*   **Nominalization**: Transforms a process or action (a verb) into a concept that can be treated as a noun. This is for when the `normtext` describes a process as a thing in itself.
    *   *Example Question*: "What process is `{user authentication}` defined as?" (e.g., "...: user authentication is the process of verifying a user...")
    *   *Explanation*: The action `::(verify a user)` is being turned into the object `{user authentication}`.

*   **Continuation/Extension**: Extends an existing sequence, collection, or concept by adding something to it.
    *   *Example Question*: "What continuation is `{updated sequence}` formed from?" (e.g., "...: the updated sequence is the result of adding a new number to the old one...")
    *   *Explanation*: A new state of a concept is created from a previous state plus an addition.

*   **Instantiation**: Defines a concept by enumerating its specific, concrete members or instances.
    *   *Example Question*: "What are the specific instances of `{number sequence}`?" (e.g., "...: the sequence is 1, 2, 3...")
    *   *Explanation*: The abstract concept `{number sequence}` is being defined by the literal values `[1, 2, 3]`.

*   **Identification**: Asserts that a concept is identical to another specific, marked instance of a concept that has been defined elsewhere. This is for linking, not defining.
    *   **Example Question**: "What are identities of `{number sequence}`?" (e.g., "...: the number sequence is the same as the one marked by {1}...")
    *   *Explanation*: This connects the current concept to a pre-existing, tagged version of it.

*   **Annotated Composition**: Groups multiple concepts together into a structured record where each concept is a named field. This is for creating complex data structures, like a list of objects.
    *   *Example Question*: "How are `{position}` and `{value}` composed into an annotated structure?" (e.g., "...: a sequence of numbers indexed by their position and value...")
    *   *Explanation*: This creates a relation where `{position}` and `{value}` are linked together as complementary fields in a structure.

*   **Ordered Composition**: Combines or concatenates two or more ordered concepts (like lists or sequences) into a single new one.
    *   *Example Question*: "How is `{number sequence}` composed as an ordered sequence?" (e.g., "...: the sequence is a combination of sequence 1 and sequence 2...")
    *   *Explanation*: This joins multiple sequences end-to-end to form a longer one.

*   **Process Request**: Asks how to perform an action that is directly related to or performed by an object. It attaches a capability or method to an object.
    *   *Example Question*: How to find `{the user}` with some process?" (e.g., "...: find the user with their name...")
    *   *Explanation*: This links the object `{the user}` with the action `::(find user by name)`.

*   **I/O Request**: Asks how a piece of data is obtained from an external source (input) or sent to an external destination (output).
    *   *Example Question*: How to acquire `{username}` as input?" (e.g., "...: the username is input by the user...")
    *   *Explanation*: This defines that the value for `{username}` comes from an external input operation.
    
*   **Judgement Request**: Asks about evaluating a boolean state, condition, or property of an object. The result is fundamentally a true/false evaluation.
    *   *Example Question*: How to judge the truth of the statement `<user is an admin>`?" (e.g., "...: if the user is an admin...")
    *   *Explanation*: This question leads to the creation of a statement like `<user is an admin>` which can be evaluated.

*   **Element-wise Breakdown**: Asks how an operation is applied individually to every item in a collection to produce a new collection of the same size.
    *   *Example Question*: How to square every element of `{number sequence}` by each of its member?" (e.g., "...: the sequence is squared by squaring each of its members...")
    *   *Explanation*: This describes a transformation (squaring) that is applied to `*every` member of a set.

***

**B. Questions for Action-Like Concepts**

These questions are used when the `...:` text is describing the logic, method, or conditions for performing an action (`::()`, `::< >`).

*   **Methodology Declaration**: Specifies the method or means by which an action is performed.
    *   *Example Question*: "By what method is `::(Authenticate the user)` performed?" (e.g., "...: authenticate the user by checking their password...")
    *   *Explanation*: This seeks to define the implementation or procedure for carrying out the action `::(Authenticate the user)`.

*   **Conditional Dependency**: Asks about the condition required for an action to occur.
    *   *Example Question*: "Under what condition is `::(Show the admin dashboard)` executed?" (e.g., "...: show the dashboard if the user is an admin...")
    *   *Explanation*: This asks for the prerequisite boolean state (e.g., `<user is an admin>`) that must be true for the action to proceed.

*   **Sequential Dependency**: Asks about the order of actions.
    *   *Example Question*: "After what event is `::(Show the admin dashboard)` executed?" (e.g., "...: show the dashboard after the user is authenticated...")
    *   *Explanation*: This seeks to establish a temporal link, defining which action or event must complete before this one can begin.

**Example:**

Input Concept to Decompose:
```normcode
:<:(::(Authenticate the user))
    ...: Authenticate the user by checking their password.
```

Output:
```json
{
  "question": "How do you authenticate the user?",
  "question_type": "Methodology Declaration"
}
```

**Concept to Decompose:**
---
{concept to decomposed}
---
**Remaining Normtext:**
---
{remaining normtext}
---

Respond with a JSON object containing two keys: "question" and "question_type".

