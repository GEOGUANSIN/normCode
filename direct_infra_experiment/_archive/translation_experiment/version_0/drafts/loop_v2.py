import uuid
import logging
import os
import sys
import argparse
from pathlib import Path

# --- Infra Imports ---
try:
    from infra import Inference, Concept, AgentFrame, Reference, BaseStates
    from infra._orchest._blackboard import Blackboard
    from infra._orchest._repo import ConceptEntry, InferenceEntry, ConceptRepo, InferenceRepo
    from infra._orchest._waitlist import WaitlistItem, Waitlist
    from infra._orchest._tracker import ProcessTracker
    from infra._orchest._orchestrator import Orchestrator
    from infra._loggers.utils import setup_orchestrator_logging
    from infra._agent._body import Body
except Exception:
    # If infra is not in the path, add it.
    # This is for running the script directly.
    # Need to go up 4 levels from here to reach project root where infra/ is located:
    # drafts -> version_0 -> translation_experiment -> direct_infra_experiment -> normCode (project root)
    here = Path(__file__).parent
    project_root = here.parent.parent.parent.parent
    sys.path.insert(0, str(project_root))
    from infra import Inference, Concept, AgentFrame, Reference, BaseStates
    from infra._orchest._blackboard import Blackboard
    from infra._orchest._repo import ConceptEntry, InferenceEntry, ConceptRepo, InferenceRepo
    from infra._orchest._waitlist import WaitlistItem, Waitlist
    from infra._orchest._tracker import ProcessTracker
    from infra._orchest._orchestrator import Orchestrator
    from infra._loggers.utils import setup_orchestrator_logging
    from infra._agent._body import Body


# --- Normcode for this example ---
Normcode_v0_manual = """
:<:({normcode draft})

    <= $.({normcode draft})

    <- [all {normcode draft}]<$={1}>
        <= &across({normcode draft})
        <- {normcode draft}<$={1}>
            |%: [":<:({dummy concept}) \n    ...: The dummy concept is a dummy concept."]
    
    <- {normcode draft}<$={2}> | 1.3. quantifying
        <= *every([all {normcode draft}]<$={1}>)@(1) | 1.3.1. assignment

            <= $.({normcode draft}<$={2}>) 

            <- [all {normcode draft}]<$={1}>
                <= &across({normcode draft})
                <- {normcode draft}<$={2}>

            <- <current normcode draft is complete> | 1.3.1.1. judgement
                <= ::{%(direct)}<{prompt}<$(completion check prompt)%>: {1}<$({current normcode draft})%> is a complete>
                <- {completion check prompt}<:{prompt}>
                    |%{prompt_location}: completion_check_prompt
                <- [all {normcode draft}]<$={1}>*1<:{1}>

            <- {normcode draft}<$={2}>  | 1.3.2.1. assignment
                <= $.([all {normcode draft}]<$={1}>*1) | 1.3.2.1. timing
                    <= @if(<current normcode draft is complete>)
                    <- <current normcode draft is complete>
                <- [all {normcode draft}]<$={1}>*1

            <- {normcode draft}<$={2}> | 1.3.3.1. assignment
                <= $.({normcode draft}<$={3}>) | 1.3.3.1. timing
                    <= @if!(<current normcode draft is complete>)
                    <- <current normcode draft is complete>

                <- {normcode draft}<$={3}> | 1.3.3.1.7. imperative
                    <= ::{%(direct)}<{prompt}<$(normcode draft one step decomposition prompt)%>: {1}<$({normcode draft})%>>
                    <- {normcode draft one step decomposition prompt}<:{prompt}>
                        |%{prompt_location}: normcode_draft_update_prompt
                    <- [all {normcode draft}]<$={1}>*1<:{1}>


        <- [all {normcode draft}]<$={1}>
"""


def create_repositories():
    """Creates concept and inference repositories for a pre-loop assignment scenario."""
    concept_entries = [
        # Ground Concepts
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="{number sequence}",
            type="[]",
            description="A sequence of numbers to loop over.",
            is_ground_concept=True,
            reference_data=["1", "2"],
            reference_axis_names=["sequence"],
        ),
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="{normcode draft}<$={1}>",
            type="{}",
            description="The source draft, which is a ground concept.",
            is_ground_concept=True,
            reference_data=["This is the initial draft."],
            reference_axis_names=["text"],
        ),

        # Inferred Concepts
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="{normcode draft}<$={2}>",
            type="{}",
            description="The destination draft, to be inferred within the loop.",
        ),
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="[All {normcode draft}]",
            type="[]",
            description="The final collection of all drafts generated by the loop.",
            is_final_concept=True,
        ),
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="{number sequence}*1",
            type="[]",
            description="The current item from the number sequence in a loop.",
        ),

        # Functional Concepts
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="*every({number sequence})@(1)",
            type="*every",
            description="The quantifier for the main loop.",
        ),
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="$.({normcode draft}<$={1}>)",
            type="$.",
            description="The inner assignment operation.",
            is_ground_concept=True,
        ),
        ConceptEntry(
            id=str(uuid.uuid4()),
            concept_name="$.({normcode draft}<$={2}>)",
            type="$.",
            description="The outer assignment for the loop result.",
            is_ground_concept=True,
        ),
    ]
    concept_repo = ConceptRepo(concept_entries)

    # --- Inference Entries ---
    inference_entries = [
        # Initial Assignment (runs once before the loop)
        InferenceEntry(
            id=str(uuid.uuid4()),
            inference_sequence='assigning',
            concept_to_infer=concept_repo.get_concept('{normcode draft}<$={2}>'),
            function_concept=concept_repo.get_concept('$.({normcode draft}<$={1}>)'),
            value_concepts=[concept_repo.get_concept('{normcode draft}<$={1}>')],
            flow_info={'flow_index': '1.1'},
            working_interpretation={"syntax": {"marker": ".", "assign_source": "{normcode draft}<$={1}>", "assign_destination": "{normcode draft}<$={2}>"}}
        ),
        # In-Loop Assignment (defines the result of a single loop iteration)
        InferenceEntry(
            id=str(uuid.uuid4()),
            inference_sequence='assigning',
            concept_to_infer=concept_repo.get_concept('*every({number sequence})@(1)'),
            function_concept=concept_repo.get_concept('$.({normcode draft}<$={2}>)'),
            value_concepts=[concept_repo.get_concept('{normcode draft}<$={2}>')],
            flow_info={'flow_index': '1.2.1'},
            working_interpretation={"syntax": {"marker": ".", "assign_source": "{normcode draft}<$={2}>", "assign_destination": "*every({number sequence})@(1)"}}
        ),
        # Quantifying Inference (the main loop)
        InferenceEntry(
            id=str(uuid.uuid4()),
            inference_sequence='quantifying',
            concept_to_infer=concept_repo.get_concept('[All {normcode draft}]'),
            function_concept=concept_repo.get_concept('*every({number sequence})@(1)'),
            value_concepts=[concept_repo.get_concept('{number sequence}')],
            context_concepts=[concept_repo.get_concept('{number sequence}*1')],
            flow_info={'flow_index': '1.2'},
            working_interpretation={
                "syntax": {
                    "marker": "every",
                    "quantifier_index": 1,
                    "LoopBaseConcept": "{number sequence}",
                    "CurrentLoopBaseConcept": "{number sequence}*1",
                    "ConceptToInfer": ["[All {normcode draft}]"]
                }
            },
            start_without_value_only_once=True,
            start_without_function_only_once=True,
            start_with_support_reference_only=True
        ),
    ]
    inference_repo = InferenceRepo(inference_entries)
    return concept_repo, inference_repo


if __name__ == "__main__":
    # Setup file logging
    log_filename = setup_orchestrator_logging(__file__)
    logging.info("=== Starting @before Timing Demo ===")
    logging.info("This demo tests if an assignment happens only when the target is not yet complete.")

    # 1. Create repositories
    concept_repo, inference_repo = create_repositories()

    # 2. Initialize and run the orchestrator
    orchestrator = Orchestrator(
        concept_repo=concept_repo,
        inference_repo=inference_repo,
        max_cycles=10,
    )

    # 3. Run the orchestrator
    final_concepts = orchestrator.run()

    # 4. Log the final result
    logging.info("--- Final Concepts Returned ---")
    for final_concept_entry in final_concepts:
        if final_concept_entry and final_concept_entry.concept.reference:
            ref_tensor = final_concept_entry.concept.reference.tensor
            logging.info(f"  - Final Concept '{final_concept_entry.concept_name}': {ref_tensor}")
            print(f"\nFinal concept '{final_concept_entry.concept_name}':")
            print(f"  Value: {ref_tensor}")
        else:
            logging.warning(f"No reference found for final concept '{final_concept_entry.concept_name}'.")
            print(f"\nNo reference found for final concept '{final_concept_entry.concept_name}'.")

    logging.info(f"=== @before Timing Demo Complete - Log saved to {log_filename} ===")
    print(f"\n{'='*80}")
    print("PROGRAM COMPLETED")
    print(f"{'='*80}")