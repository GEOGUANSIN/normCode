"""
Result validation function for the number pair addition example.

This module provides comprehensive validation for the results generated by the
orchestrator, including digit-by-digit analysis and structure validation.
"""

import re
import logging
from typing import List, Dict, Any, Tuple, Optional, Union
from dataclasses import dataclass


@dataclass
class ValidationResult:
    """Container for validation results."""
    is_valid: bool
    errors: List[str]
    warnings: List[str]
    digit_analysis: Dict[str, Any]
    expected_values: Dict[str, Any]
    actual_values: Dict[str, Any]


class ResultValidator:
    """Validates the results from the number pair addition orchestrator."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    def validate_final_concept(self, 
                             concept_name: str,
                             data_tensor: List,
                             axis_names: List[str], 
                             shape: Tuple,
                             input_numbers: Tuple[str, str]) -> ValidationResult:
        """
        Validate the final concept result with comprehensive analysis.
        
        Args:
            concept_name: Name of the concept (e.g., "{new number pair}")
            data_tensor: The nested tensor data structure
            axis_names: List of axis names for the tensor
            shape: Shape of the tensor
            input_numbers: Tuple of input numbers (number_1, number_2)
            
        Returns:
            ValidationResult with detailed analysis
        """
        errors = []
        warnings = []
        digit_analysis = {}
        expected_values = {}
        actual_values = {}
        
        # Basic structure validation
        self._validate_structure(data_tensor, axis_names, shape, errors, warnings)
        
        # Extract and validate the actual number pairs
        if not errors:
            extracted_pairs = self._extract_number_pairs(data_tensor, axis_names)
            actual_values['extracted_pairs'] = extracted_pairs
            
            # Calculate expected values
            expected_pairs = self._calculate_expected_pairs(input_numbers)
            expected_values['expected_pairs'] = expected_pairs
            
            # Digit-by-digit analysis
            digit_analysis = self._analyze_digits(extracted_pairs, expected_pairs, input_numbers)
            
            # Validate the results
            self._validate_calculations(extracted_pairs, expected_pairs, errors, warnings)
            
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            digit_analysis=digit_analysis,
            expected_values=expected_values,
            actual_values=actual_values
        )
    
    def _validate_structure(self, data_tensor: List, axis_names: List[str], 
                          shape: Tuple, errors: List[str], warnings: List[str]):
        """Validate the basic structure of the result."""
        
        # Check if data_tensor is a list
        if not isinstance(data_tensor, list):
            errors.append(f"Data tensor should be a list, got {type(data_tensor)}")
            return
            
        # Check if we have the expected number of elements
        if len(data_tensor) != shape[0]:
            errors.append(f"Expected {shape[0]} elements in first dimension, got {len(data_tensor)}")
            
        # Check axis names
        expected_axes = ['number pair', 'get remainder', 'remainder explanation', 'sum', 
                        'get unit place digit', 'unit place digit', 'carry-over number']
        if axis_names != expected_axes:
            warnings.append(f"Axis names differ from expected: {axis_names} vs {expected_axes}")
            
        # Validate tensor depth and structure
        self._validate_tensor_depth(data_tensor, shape, errors)
    
    def _validate_tensor_depth(self, tensor: List, shape: Tuple, errors: List[str], depth: int = 0):
        """Recursively validate tensor depth and structure."""
        if depth >= len(shape):
            # We've reached the deepest level
            if isinstance(tensor, list) and len(tensor) > 0:
                errors.append(f"Tensor is deeper than expected shape {shape}")
            return
            
        if not isinstance(tensor, list):
            errors.append(f"Expected list at depth {depth}, got {type(tensor)}")
            return
            
        if len(tensor) != shape[depth]:
            errors.append(f"Expected {shape[depth]} elements at depth {depth}, got {len(tensor)}")
            
        # Recursively check nested structure
        for i, element in enumerate(tensor):
            if isinstance(element, list):
                self._validate_tensor_depth(element, shape, errors, depth + 1)
    
    def _extract_number_pairs(self, data_tensor: List, axis_names: List[str]) -> List[Tuple[str, str]]:
        """Extract number pairs from the nested tensor structure."""
        pairs = []
        
        # Navigate through the nested structure to find the actual number pairs
        # Based on the log, the structure is: [[[[[[['%00d(4)']]]]]], [[[[[['%7fd(0)']]]]]], [[[[[['%9a8(1)']]]]]]]
        
        for pair_data in data_tensor:
            # Navigate to the deepest level where the actual data is stored
            current = pair_data
            while isinstance(current, list) and len(current) == 1:
                current = current[0]
                
            # Extract the number pair from the deepest level
            if isinstance(current, list) and len(current) >= 2:
                # Parse the encoded numbers
                num1_encoded = self._extract_encoded_number(current[0])
                num2_encoded = self._extract_encoded_number(current[1]) if len(current) > 1 else "0"
                
                pairs.append((num1_encoded, num2_encoded))
            else:
                pairs.append(("0", "0"))
                
        return pairs
    
    def _extract_encoded_number(self, encoded_str: str) -> str:
        """Extract the actual number from an encoded string like '%00d(4)'."""
        if not isinstance(encoded_str, str):
            return "0"
            
        # Pattern: '%' followed by hex digits, then '(' followed by decimal digits, then ')'
        match = re.match(r"%([0-9a-f]+)\((\d+)\)", encoded_str)
        if match:
            hex_part = match.group(1)
            decimal_part = match.group(2)
            return decimal_part
        else:
            # Try to extract any number from the string
            numbers = re.findall(r'\d+', encoded_str)
            return numbers[0] if numbers else "0"
    
    def _calculate_expected_pairs(self, input_numbers: Tuple[str, str]) -> List[Tuple[str, str]]:
        """Calculate what the expected number pairs should be."""
        num1, num2 = input_numbers
        
        # Convert to integers for calculation
        try:
            n1 = int(num1)
            n2 = int(num2)
        except ValueError:
            return [("0", "0")]
            
        # Simulate the digit-by-digit addition process
        expected_pairs = []
        
        # Pad numbers to same length
        max_len = max(len(num1), len(num2))
        num1_padded = num1.zfill(max_len)
        num2_padded = num2.zfill(max_len)
        
        carry = 0
        result_digits = []
        
        # Process from right to left (least significant digit first)
        for i in range(max_len - 1, -1, -1):
            digit1 = int(num1_padded[i])
            digit2 = int(num2_padded[i])
            
            # Calculate sum with carry
            digit_sum = digit1 + digit2 + carry
            result_digit = digit_sum % 10
            carry = digit_sum // 10
            
            result_digits.append(str(result_digit))
            
            # Create intermediate pairs for validation
            # Remove processed digits from numbers
            remaining_num1 = num1_padded[:i+1] if i+1 < len(num1_padded) else "0"
            remaining_num2 = num2_padded[:i+1] if i+1 < len(num2_padded) else "0"
            
            expected_pairs.append((remaining_num1, remaining_num2))
        
        # Add final pair if there's a carry
        if carry > 0:
            expected_pairs.append(("0", "0"))
            
        return expected_pairs
    
    def _analyze_digits(self, actual_pairs: List[Tuple[str, str]], 
                       expected_pairs: List[Tuple[str, str]], 
                       input_numbers: Tuple[str, str]) -> Dict[str, Any]:
        """Perform digit-by-digit analysis."""
        analysis = {
            'input_numbers': input_numbers,
            'total_pairs': len(actual_pairs),
            'digit_comparisons': [],
            'errors_by_position': {},
            'summary': {}
        }
        
        max_pairs = max(len(actual_pairs), len(expected_pairs))
        
        for i in range(max_pairs):
            actual = actual_pairs[i] if i < len(actual_pairs) else ("0", "0")
            expected = expected_pairs[i] if i < len(expected_pairs) else ("0", "0")
            
            comparison = {
                'position': i,
                'actual': actual,
                'expected': expected,
                'matches': actual == expected,
                'num1_match': actual[0] == expected[0],
                'num2_match': actual[1] == expected[1]
            }
            
            # Detailed digit analysis
            if not comparison['matches']:
                comparison['digit_errors'] = []
                
                # Compare each digit position
                max_len = max(len(actual[0]), len(expected[0]), len(actual[1]), len(expected[1]))
                
                for digit_pos in range(max_len):
                    actual_digit1 = actual[0][-(digit_pos+1)] if digit_pos < len(actual[0]) else '0'
                    expected_digit1 = expected[0][-(digit_pos+1)] if digit_pos < len(expected[0]) else '0'
                    actual_digit2 = actual[1][-(digit_pos+1)] if digit_pos < len(actual[1]) else '0'
                    expected_digit2 = expected[1][-(digit_pos+1)] if digit_pos < len(expected[1]) else '0'
                    
                    if actual_digit1 != expected_digit1 or actual_digit2 != expected_digit2:
                        comparison['digit_errors'].append({
                            'digit_position': digit_pos,
                            'actual_digits': (actual_digit1, actual_digit2),
                            'expected_digits': (expected_digit1, expected_digit2)
                        })
                        
                        analysis['errors_by_position'][f'pair_{i}_digit_{digit_pos}'] = {
                            'actual': (actual_digit1, actual_digit2),
                            'expected': (expected_digit1, expected_digit2)
                        }
            
            analysis['digit_comparisons'].append(comparison)
        
        # Summary statistics
        total_comparisons = len(analysis['digit_comparisons'])
        matching_pairs = sum(1 for comp in analysis['digit_comparisons'] if comp['matches'])
        
        analysis['summary'] = {
            'total_pairs': total_comparisons,
            'matching_pairs': matching_pairs,
            'accuracy_percentage': (matching_pairs / total_comparisons * 100) if total_comparisons > 0 else 0,
            'total_digit_errors': len(analysis['errors_by_position'])
        }
        
        return analysis
    
    def _validate_calculations(self, actual_pairs: List[Tuple[str, str]], 
                              expected_pairs: List[Tuple[str, str]], 
                              errors: List[str], warnings: List[str]):
        """Validate that the calculations are correct."""
        
        if len(actual_pairs) != len(expected_pairs):
            warnings.append(f"Different number of pairs: actual {len(actual_pairs)} vs expected {len(expected_pairs)}")
        
        # Check each pair
        for i, (actual, expected) in enumerate(zip(actual_pairs, expected_pairs)):
            if actual != expected:
                errors.append(f"Pair {i}: actual {actual} != expected {expected}")
    
    def validate_from_log_entry(self, log_entry: Dict[str, Any]) -> ValidationResult:
        """
        Validate result from a parsed log entry.
        
        Args:
            log_entry: Dictionary containing:
                - concept_name: str
                - data_tensor: List
                - axis_names: List[str]
                - shape: Tuple
                - input_numbers: Tuple[str, str]
                
        Returns:
            ValidationResult
        """
        return self.validate_final_concept(
            concept_name=log_entry['concept_name'],
            data_tensor=log_entry['data_tensor'],
            axis_names=log_entry['axis_names'],
            shape=log_entry['shape'],
            input_numbers=log_entry['input_numbers']
        )
    
    def print_validation_report(self, result: ValidationResult):
        """Print a detailed validation report."""
        print("\n" + "="*60)
        print("VALIDATION REPORT")
        print("="*60)
        
        print(f"\nOverall Status: {'‚úì VALID' if result.is_valid else '‚úó INVALID'}")
        
        if result.errors:
            print(f"\n‚ùå ERRORS ({len(result.errors)}):")
            for error in result.errors:
                print(f"  - {error}")
        
        if result.warnings:
            print(f"\n‚ö†Ô∏è  WARNINGS ({len(result.warnings)}):")
            for warning in result.warnings:
                print(f"  - {warning}")
        
        # Digit analysis summary
        if result.digit_analysis:
            analysis = result.digit_analysis
            print(f"\nüìä DIGIT ANALYSIS:")
            print(f"  - Input Numbers: {analysis['input_numbers']}")
            print(f"  - Total Pairs: {analysis['total_pairs']}")
            
            if 'summary' in analysis:
                summary = analysis['summary']
                print(f"  - Matching Pairs: {summary['matching_pairs']}/{summary['total_pairs']}")
                print(f"  - Accuracy: {summary['accuracy_percentage']:.1f}%")
                print(f"  - Digit Errors: {summary['total_digit_errors']}")
            
            # Show detailed comparisons
            print(f"\nüîç DETAILED COMPARISONS:")
            for comp in analysis['digit_comparisons']:
                status = "‚úì" if comp['matches'] else "‚úó"
                print(f"  {status} Position {comp['position']}: {comp['actual']} vs {comp['expected']}")
                
                if not comp['matches'] and 'digit_errors' in comp:
                    for digit_error in comp['digit_errors']:
                        pos = digit_error['digit_position']
                        actual = digit_error['actual_digits']
                        expected = digit_error['expected_digits']
                        print(f"    ‚ùå Digit {pos}: {actual} vs {expected}")
        
        print("\n" + "="*60)


def create_test_data():
    """Create test data based on the log example."""
    return {
        'concept_name': '{new number pair}',
        'data_tensor': [
            [[[[[['%00d(4)']]]]]], 
            [[[[[['%7fd(0)']]]]]], 
            [[[[[['%9a8(1)']]]]]]
        ],
        'axis_names': ['number pair', 'get remainder', 'remainder explanation', 'sum', 
                      'get unit place digit', 'unit place digit', 'carry-over number'],
        'shape': (3, 1, 1, 1, 1, 1, 1),
        'input_numbers': ('12', '92')
    }


if __name__ == "__main__":
    # Test the validator with the example data
    validator = ResultValidator()
    test_data = create_test_data()
    
    print("Testing Result Validator with example data...")
    print(f"Input numbers: {test_data['input_numbers']}")
    print(f"Data tensor: {test_data['data_tensor']}")
    
    result = validator.validate_from_log_entry(test_data)
    validator.print_validation_report(result)
