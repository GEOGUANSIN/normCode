\section{The Execution Model}

While the NormCode language defines \textit{what} a plan should do, the execution model defines \textit{how} and \textit{when} it happens. This section describes the Orchestrator (the central execution engine), Agent Sequences (execution pipelines for each inference type), and Paradigms (declarative configuration of agent behavior).

\subsection{The Orchestrator}

The Orchestrator is the runtime engine of NormCode. It manages the execution of a plan by tracking dependencies, scheduling inferences, and maintaining state.

\textbf{Core Components:} (1) \textbf{Waitlist}: A prioritized queue of all inferences in the plan, sorted by flow index, defining the \textit{structural order}; (2) \textbf{Blackboard}: A real-time state tracker where every concept/inference has a status (\texttt{pending}, \texttt{in\_progress}, \texttt{completed}, \texttt{skipped}); and (3) \textbf{Repositories}: The Concept and Inference Repositories storing data and configuration.

\textbf{Execution Cycle:} The Orchestrator runs in cycles. In each cycle, it \textbf{scans} the Waitlist for \texttt{pending} inferences whose dependencies are met, \textbf{executes} the inference by invoking the appropriate Agent Sequence, and \textbf{updates} the Blackboard and Concept Repository with the result.

This \textbf{dependency-driven scheduling} ensures that inferences run only when their inputs are ready, and that failures in one branch do not corrupt unrelated branches.

\subsection{Persistence and Checkpointing}

For long-running or resumable workflows, the Orchestrator provides a robust checkpointing system backed by SQLite. Features include: \textbf{Run ID} for tracking; \textbf{Snapshots} of the full state at each cycle; \textbf{Resume} capability with reconciliation modes (\texttt{PATCH}, \texttt{OVERWRITE}, \texttt{FILL\_GAPS}); and \textbf{Fork} functionality to branch from a past state.

\subsection{Agents and the AgentFrame}

In NormCode, an \textbf{Agent} is not just an abstract actor---it is a concrete container of capability, represented by the \textbf{Subject Concept} (\texttt{:S:}). When a functional concept executes, it does so \textit{within} an Agent's context.

The \textbf{AgentFrame} class realizes this in the implementation, containing the **Body** (the agent's ``toolbox''), **Sequences** (pipelines the agent can run), and **Mode** (interpretation style). This design enables \textbf{multi-agent planning}: different Subjects can have different tool bodies and capabilities.

\subsection{Agent Sequences: The Execution Pipelines}

Each inference type triggers a specific \textbf{Agent Sequence}---a standardized pipeline of steps.

\textbf{Semantic Sequences (LLM-Invoking):}

\begin{table}[t!]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Sequence} & \textbf{Steps} & \textbf{Purpose} \\ 
\midrule
\texttt{imperative} & IWI $\to$ IR $\to$ MFP $\to$ MVP $\to$ TVA $\to$ OR $\to$ OWI & Execute commands/actions \\ 
\texttt{judgement} & IWI $\to$ IR $\to$ MFP $\to$ MVP $\to$ TVA $\to$ TIA $\to$ OR $\to$ OWI & Evaluate conditions \\ 
\bottomrule
\end{tabular}
\caption{Semantic Agent Sequences (LLM-invoking).}
\label{tab:semantic_sequences}
\end{table*}

The key steps are: **MFP (Model Function Perception)** resolves the ``vertical'' input; **MVP (Memory Value Perception)** prepares ``horizontal'' inputs; and **TVA (Tool Value Actuation)** applies the function to values (invoking the LLM).

\textbf{Syntactic Sequences (Deterministic):}

\begin{table}[t!]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Sequence} & \textbf{Key Step} & \textbf{Purpose} \\ 
\midrule
\texttt{assigning} & AR & Select/specify values \\ 
\texttt{grouping} & GR & Collect inputs \\ 
\texttt{timing} & T & Check conditions \\ 
\texttt{looping} & LR & Iterate over collections \\ 
\bottomrule
\end{tabular}
\caption{Syntactic Agent Sequences (Deterministic).}
\label{tab:syntactic_sequences}
\end{table}

These sequences manipulate Reference structures without any AI involvement. They are instant, free, and 100\% deterministic.

\subsection{Paradigms: Configuring Agent Behavior}

A \textbf{Paradigm} is a declarative JSON specification that configures \textit{how} an agent executes a semantic inference. It bridges the gap between abstract intent (``summarize this document'') and concrete execution (which prompt template, which LLM, which output format).

\textbf{The Vertical/Horizontal Split:} Paradigms separate configuration into: (1) \textbf{Vertical Steps} (Construction-Time), handled during MFP to resolve tool affordances; and (2) \textbf{Horizontal Steps} (Runtime), handled during TVA to pass data values through the function.

\textbf{Mathematical Formalization:}

Let $\mathcal{S}$ be the Agent's state, $V_{spec}$ be the vertical specification (paradigm), and $H_{plan}$ be the horizontal plan. Let $\mathcal{V}$ be the runtime values.

\begin{equation}
\mathcal{O} = [F_C(F_V(\mathcal{S}, V_{spec}), H_{plan})](\mathcal{V})
\end{equation}

Where $F_V$ is the vertical function (MFP phase) producing tool handles $\mathcal{T}$, $F_C$ is the composition function compiling $\mathcal{T}$ and $H_{plan}$ into function $\Phi$, and $\Phi(\mathcal{V})$ is the horizontal execution (TVA phase) producing output $\mathcal{O}$.

This clean separation allows paradigms to be reused across different inferences and agents.

\subsection{Tooling}

NormCode provides two primary interfaces for running and monitoring orchestrations: a \textbf{CLI} (\texttt{cli\_orchestrator.py}) supporting `run`, `resume`, `fork`, and `list-runs`; and a \textbf{Streamlit App} for visualizing the plan hierarchy and real-time status.

