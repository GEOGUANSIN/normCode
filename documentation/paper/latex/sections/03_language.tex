\section{The NormCode Language}

NormCode is designed around a single fundamental unit: the \textbf{inference}. An inference is not merely a function call; it is a structured assertion: ``Concept A is obtained by performing Operation B on Inputs C and D.'' This structure enforces the data isolation required for reliable AI planning.

\subsection{Core Syntax: The Inference Structure}

A NormCode plan is a hierarchy of inferences. We define two primary concept markers: \texttt{<=} (\textbf{Functional Concept}) defines the operation (the ``verb'') and triggers an agent sequence, while \texttt{<-} (\textbf{Value Concept}) defines the data (the ``noun'') holding the input or output state.

A typical inference looks like this in \texttt{.ncds} (NormCode Draft Straightforward):

\begin{verbatim}
<- summary
    <= summarize the text
    <- raw document
\end{verbatim}

This is read bottom-up: ``The \texttt{raw document} is used to \texttt{summarize the text}, producing the \texttt{summary}.'' The indentation defines the dependency: the parent (\texttt{summary}) cannot be resolved until its children (\texttt{summarize...}) are complete.

\subsection{The Three-Format Ecosystem}

NormCode acknowledges that humans, compilers, and reviewers have different needs. The language exists in three isomorphic formats: (1) \textbf{.ncds (Draft Straightforward)}: The human authoring format using natural language with minimal structural markers (\texttt{<-}, \texttt{<=}) to prioritize speed; (2) \textbf{.ncd (Draft)}: The formal intermediate representation generated by the compiler, resolving all ambiguities (types, value orders, flow indices) for machine execution; and (3) \textbf{.ncn (Natural)}: A compiler-generated narrative translating the formal \texttt{.ncd} back into plain English (e.g., ``(OUTPUT) The summary (ACTION) is obtained by...'') for verification by non-technical experts.

\subsection{Semantic Concept Types (The ``Meaning'')}

NormCode types are semantic, not just structural. They tell the agent \textit{what} the data represents in the world.

\textbf{Entities (Non-Functional)} include: \textbf{Objects \texttt{\{\}}} (discrete items, e.g., \texttt{\{file\}}), \textbf{Propositions \texttt{<>}} (boolean states, e.g., \texttt{<file exists>}), \textbf{Relations \texttt{[]}} (collections or mappings), and \textbf{Subjects \texttt{:S:}} (active agents, e.g., \texttt{:coder\_agent:}). \textbf{Operations (Functional)} include: \textbf{Imperative \texttt{(\{\})}} (commands that change state, e.g., \texttt{::(calculate sum)}, invoking the \textbf{Imperative Sequence}) and \textbf{Judgement \texttt{<\{\}>}} (evaluations returning a truth value, invoking the \textbf{Judgement Sequence}).

\subsection{Syntactic Concept Types (The ``Structure'')}

While semantic concepts invoke AI reasoning, syntactic concepts manage the plan's data flow deterministically. These include: \textbf{Assigning} (\texttt{\$=}, \texttt{\$.}, \texttt{\$+} to select outputs or carry state); \textbf{Grouping} (\texttt{\&in}, \texttt{\&across} to structure multiple inputs); \textbf{Timing} (\texttt{@if}, \texttt{@if!}, \texttt{@after} to control execution order); and \textbf{Looping} (\texttt{*every} to process collections item-by-item).

\subsection{Plan Addressability}

Every step in a NormCode plan is assigned a unique \textbf{Flow Index} (e.g., \texttt{1.2.3}) based on its indentation depth. This index serves as a permanent address for that inference, enabling \textbf{Precise Debugging} (``The error occurred at step 1.4.2''), \textbf{Targeted Intervention} (``Pause execution before step 2.1 starts''), and \textbf{Auditing} (``Show me the inputs for step 3.2'').

\subsection{Semi-Formality: Balancing Structure and Flexibility}

NormCode's ``semi-formal'' nature operates in two complementary ways:

\textbf{1. Conceptual Preservation (Progressive Formalization).} NormCode allows natural language content within formal structure. A user can write \texttt{::(summarize the text)} without immediately defining implementation details. The structure formalizes \textit{how} the concept relates to others (it is an action with dependencies), while leaving \textit{content} flexible until execution. Plans can start as rough sketches and be iteratively refined into rigorous logic---supporting exploration before commitment.

\textbf{2. Strictness Only Where Necessary.} Syntax is strict precisely to the extent required for compilation: to establish unique concept identities, resolve data flow dependencies, and extract working interpretations (which agent sequence to invoke).

Beyond these requirements, semantic content can remain in natural language. This prevents the brittleness of traditional formal methods (where a single syntax error invalidates the entire specification) while providing sufficient structure for reliable orchestration.

