\section{Discussion}

\subsection{When to Use NormCode}

NormCode is designed for scenarios where explicit auditability and data isolation justify the overhead. **Strong fit** scenarios include: high-stakes decisions (traceability required), complex multi-step reasoning (debugging needed), long-running workflows (checkpointing), and human-AI collaboration. **Poor fit** scenarios include: simple Q\&A (direct prompting suffices), rapid prototyping (overhead costs), and real-time applications (latency).

The ``sweet spot'' is workflows where reliability and transparency outweigh the cost of explicit structure.

\subsection{Limitations and Tradeoffs}

\textbf{Syntax density.} The \texttt{.ncd} format's markers (\texttt{<=}, \texttt{<-}, \texttt{<\$(\{...\})\%>}) create visual clutter. While the \texttt{.ncds} format mitigates this for authoring, debugging compiled plans requires parsing dense notation. IDE support (syntax highlighting, structure visualization) would significantly improve usability.

\textbf{Verbosity.} Simple operations expand to multiple lines. A three-step workflow that could be a 10-line Python script becomes a 30-line NormCode plan. This verbosity is the price of explicit data flow---but for complex workflows, the marginal cost decreases (a 20-step workflow is not 10$\times$ more verbose).

\textbf{Brittleness of manual editing.} The \texttt{.ncd} format is indentation-sensitive and tightly coupled to flow indices. Manual edits risk breaking dependencies. The compiler should be the primary way to modify plans, but this creates a barrier for quick fixes.

\textbf{Tooling dependency.} NormCode requires the orchestrator, compiler, and reference system. This ``batteries included'' approach limits portability compared to plain Python or LangChain. However, the integrated toolchain is necessary for the guarantees NormCode provides.

\textbf{Compiler maturity.} The NL $\to$ \texttt{.ncd} deconstruction phase relies on carefully designed prompts and is sensitive to instruction complexity. Robust error recovery and automated prompt generation remain open challenges.

\subsection{Broader Implications}

NormCode demonstrates that \textbf{structured intermediate representations can bridge human intuition and machine rigor in AI workflows}. The three-format ecosystem (author, execute, verify) suggests a general pattern for transparent AI systems: provide multiple views of the same underlying logic, each optimized for a different stakeholder.

The semantic/syntactic separation has implications beyond NormCode. As LLM-based systems move into production, operators will need precise cost attribution (``which steps burned tokens?'') and reliability mapping (``which failures were probabilistic vs. deterministic?''). NormCode's architectural separation makes these questions answerable by construction.

