\onecolumn
\section{Appendix A: Base-X Addition Repository}

This appendix provides the complete NormCode repository for the base-X addition case study described in Section 8.2.

\subsection{Input Specification}

The input to the addition plan is a simple JSON structure:

\begin{verbatim}
{
  "{number pair}": {
    "data": [["%(123)", "%(98)"]],
    "axes": ["number pair", "number"]
  }
}
\end{verbatim}

The \texttt{\%()} syntax wraps raw values as perceptual signs, deferring their interpretation until needed.

\subsection{NormCode Plan (.ncds Format)}

The human-readable plan structure (formal syntax):

\subsubsection{Natural Language Translation (.ncn Format)}

For verification by domain experts, the same plan translates to:

\begin{verbatim}
[1] (OUTPUT) The new number pair
    (ACTION) is obtained by iterating through every number pair in the collection.
    (MECHANISM) Each iteration carries forward the current carry-over number.
    
    [1.1] (OUTPUT) The result of each iteration
        (ACTION) is assigned from the remainder.
        
        [1.1.2] (OUTPUT) The digit sum
            (ACTION) is computed by summing the unit place values of all numbers 
                     together with the current carry-over number.
            (INPUT 1) All unit place values of the numbers in the current pair.
            (INPUT 2) The current carry-over number (initially 0).
            (YIELDS) The sum.
            
            [1.1.2.4] (OUTPUT) All unit place values of numbers
                (ACTION) is collected by grouping across the current number pair.
                
                [1.1.2.4.2] (OUTPUT) Each unit place value
                    (ACTION) is obtained by iterating through each number in the current pair.
                    
                    [1.1.2.4.2.1] (OUTPUT) The loop result
                        (ACTION) is assigned from the single unit place value.
                        
                        [1.1.2.4.2.1.2] (OUTPUT) The single unit place value
                            (ACTION) is extracted by getting the unit place digit of the number.
                            (INPUT) The current number from the pair.
                            (YIELDS) The extracted digit.

        [1.1.3] (OUTPUT) The number pair collection
            (ACTION) is updated by appending a new number pair.
            (CONDITION) This append happens ONLY IF NOT all numbers are zero,
                        AND IF the carry-over number is zero.
            
            [1.1.3.2] (OUTPUT) The number pair to append
                (ACTION) is constructed by iterating through each number in the current pair.
                
                [1.1.3.2.1] (OUTPUT) The loop result
                    (ACTION) is assigned from the number with last digit removed.
                    
                    [1.1.3.2.1.2] (OUTPUT) The number with last digit removed
                        (ACTION) is computed by: if the number is less than 10, output 0; 
                                 otherwise, remove the unit place digit.
                        (INPUT) The current number.
                        (YIELDS) The shifted number.

            [1.1.3.3] (OUTPUT) The proposition "all numbers are 0"
                (ACTION) is evaluated by checking if each number in the pair to append is 0.
                (TIMING) This check occurs after the number pair to append is ready.
                (CONDITION) True if ALL numbers satisfy: the number is 0.

            [1.1.3.4] (OUTPUT) The proposition "carry-over number is 0"
                (ACTION) is evaluated by checking if the carry-over number is 0.
                (TIMING) This check occurs after the number pair to append is ready.
                
                [1.1.3.4.2] (OUTPUT) The updated carry-over number
                    (ACTION) is computed from the previous carry-over and new quotient.
                    
                    [1.1.3.4.2.2] (OUTPUT) The new carry-over value
                        (ACTION) is found by computing the quotient of the digit sum divided by 10.
                        (TIMING) This occurs after the digit sum is available.
                        (INPUT) The digit sum.
                        (YIELDS) The quotient (new carry).

        [1.1.4] (OUTPUT) The remainder
            (ACTION) is computed by getting the remainder of the digit sum divided by 10.
            (TIMING) This occurs after the digit sum is available.
            (INPUT) The digit sum.
            (YIELDS) The remainder (the digit to output).

    (INPUT) The initial number pair collection.
\end{verbatim}

\textbf{Reading Guide}: 
\begin{itemize}
    \item \textbf{(OUTPUT)} = What this step produces
    \item \textbf{(ACTION)} = How it's produced
    \item \textbf{(INPUT)} = What data flows in
    \item \textbf{(YIELDS)} = The specific result extracted
    \item \textbf{(TIMING)} = Dependency on prior steps
    \item \textbf{(CONDITION)} = When the action is executed
    \item \textbf{[X.Y.Z]} = Flow index (unique address for debugging)
\end{itemize}

\subsubsection{Formal Syntax (.ncd Format)}

\begin{verbatim}
{new number pair} | 1. quantifying
    <= *every({number pair})%:[{number pair}]@(1)^[{carry-over number}<*1>] | 1.1. assigning
        <= $.({remainder}) 
        
        <- {digit sum} | 1.1.2. imperative
            <= ::(sum {1}<$([all {unit place value} of numbers])%_> and {2}<$({carry-over number}*1)%_> to get {3}?<$({sum})%_>)
            <- {sum}?<:{3}>
            <- {carry-over number}*1<:{2}> 
            <- [all {unit place value} of numbers]<:{1}> | 1.1.2.4. grouping
                <= &across({unit place value}:{number pair}*1)
                <- {unit place value} | 1.1.2.4.2. quantifying
                    <= *every({number pair}*1)%:[{number}]@(2) | 1.1.2.4.2.1. assigning
                        <= $.({single unit place value})
                        <- {single unit place value} | 1.1.2.4.2.1.2. imperative
                            <= ::(get {2}?<$({unit place value})%_> of {1}<$({number})%_>)
                            <- {unit place digit}?<:{2}>
                            <- {number pair}*1*2
                    <- {number pair}*1

        <- {number pair}<$={1}> | 1.1.3. assigning
            <= $+({number pair to append}:{number pair})%:[{number pair}] | 1.1.3.1. timing
                <= @if!(<all number is 0>) | 1.1.3.1.1. timing
                    <= @if(<carry-over number is 0>)

            <- {number pair to append}<$={1}> | 1.1.3.2. quantifying
                <= *every({number pair}*1)%:[{number}]@(3) | 1.1.3.2.1. assigning
                    <= $.({number with last digit removed}) 
                    <- {number with last digit removed} | 1.1.3.2.1.2. imperative
                        <= ::(output 0 if {1}<$({number})%_> is less than 10, otherwise remove {2}?<$({unit place digit})%_> from {1}<$({number})%_>) 
                        <- {unit place digit}?<:{2}> 
                        <- {number pair}*1*3<:{1}>
                <- {number pair}*1

            <- <all number is 0> | 1.1.3.3. judgement
                <= :%(True):<{1}<$({number})%_> is 0> | 1.1.3.3.1. timing
                    <= @after({number pair to append}<$={1}>)
                <- {number pair to append}<$={1}><:{1}>

            <- <carry-over number is 0> | 1.1.3.4. judgement
                <= :%(True):<{1}<$({carry-over number})%_> is 0> | 1.1.3.4.1. timing
                    <= @after({number pair to append}<$={1}>)
                <- {carry-over number}*1 | 1.1.3.4.2. grouping
                    <= &across({carry-over number}*1:{carry-over number}*1<--<!_>>)
                    <- {carry-over number}*1 | 1.1.3.4.2.2. imperative
                        <= ::(find the {1}?<$({quotient})%_> of {2}<$({digit sum})%_> divided by 10) | 1.1.3.4.2.2.1. timing
                            <= @after({digit sum})
                        <- {quotient}?<:{1}>
                        <- {digit sum}<:{2}>

        <- {remainder} | 1.1.4. imperative
            <= ::(get the {1}?<$({remainder})%_> of {2}<$({digit sum})%_> divided by 10) | 1.1.4.1. timing
                <= @after({digit sum})
            <- {remainder}?<:{1}>
            <- {digit sum}<:{2}>

    <- {number pair}<$={1}>
\end{verbatim}

\subsection{Concept Repository (Selected Entries)}

The concept repository defines 50+ concepts. Representative examples:

\textbf{Ground Concepts} (with pre-populated references):

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Concept Name} & \textbf{Type} & \textbf{Reference Data} \\ 
\midrule
\texttt{\{number pair\}} & \texttt{\{\}} & \texttt{[["\%(123)", "\%(98)"]]} \\ 
\texttt{\{carry-over number\}*1} & \texttt{\{\}} & \texttt{["\%(0)"]} \\ 
\texttt{\{unit place digit\}?} & \texttt{\{\}} & \texttt{"1 digit counting from the right"} \\ 
\bottomrule
\end{tabular}
\caption{Selected Ground Concepts.}
\end{table}

\textbf{Functional Concepts} (operations):

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Concept Name} & \textbf{Type} & \textbf{Description} \\ 
\midrule
\texttt{*every(\{number pair\})...} & \texttt{*every} & Outer loop with carry state \\ 
\texttt{\&across(\{unit place\}...)} & \texttt{\&across} & Group digits across numbers \\ 
\texttt{::(sum \{1\}...)} & \texttt{::(\{\})} & Imperative: digit summation \\ 
\texttt{:\%(True):<...>} & \texttt{<\{\}>} & Judgement: check if zero \\ 
\bottomrule
\end{tabular}
\caption{Selected Functional Concepts.}
\end{table}

\subsection{Inference Repository (Selected Entries)}

The inference repository contains 23 inference entries. Key examples:

\textbf{Outer Loop (flow\_index: 1)}:
\begin{verbatim}
{
  "inference_sequence": "quantifying",
  "concept_to_infer": "{new number pair}",
  "function_concept": "*every({number pair})%:[{number pair}]@(1)^[{carry-over number}<*1>]",
  "value_concepts": ["{number pair}"],
  "context_concepts": ["{number pair}*1", "{carry-over number}*1"],
  "working_interpretation": {
    "syntax": {
      "marker": "every",
      "quantifier_index": 1,
      "LoopBaseConcept": "{number pair}",
      "CurrentLoopBaseConcept": "{number pair}*1",
      "group_base": "number pair",
      "InLoopConcept": {"{carry-over number}*1": 1},
      "ConceptToInfer": ["{new number pair}"]
    }
  }
}
\end{verbatim}

\textbf{Digit Summation (flow\_index: 1.1.2)}:
\begin{verbatim}
{
  "inference_sequence": "imperative_python",
  "concept_to_infer": "{digit sum}",
  "function_concept": "::(sum {1}<...> and {2}<...> to get {3}?<...>)",
  "value_concepts": ["[all {unit place value} of numbers]", "{carry-over number}*1", "{sum}?"],
  "working_interpretation": {
    "is_relation_output": false,
    "with_thinking": true,
    "value_order": {
      "[all {unit place value} of numbers]": 1,
      "{carry-over number}*1": 2,
      "{sum}?": 3
    }
  }
}
\end{verbatim}

\textbf{Conditional Termination (flow\_index: 1.1.3.1.1)}:
\begin{verbatim}
{
  "inference_sequence": "timing",
  "concept_to_infer": "@if!(<all number is 0>)",
  "function_concept": "@if(<carry-over number is 0>)",
  "working_interpretation": {
    "syntax": {
      "marker": "if",
      "condition": "<carry-over number is 0>"
    }
  }
}
\end{verbatim}

\subsection{Repository Files}

The complete repository files are available in the codebase:
\begin{itemize}
    \item \texttt{infra/examples/add\_examples/repo/addition\_concepts.json} (935 lines)
    \item \texttt{infra/examples/add\_examples/repo/addition\_inferences.json} (656 lines)
    \item \texttt{infra/examples/add\_examples/repo/addition\_inputs.json} (12 lines)
    \item \texttt{infra/examples/add\_examples/ex\_add\_complete\_12\_base.py} (Python runner with validation)
\end{itemize}

