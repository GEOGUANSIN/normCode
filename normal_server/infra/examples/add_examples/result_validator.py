"""
Result validation function for the number pair addition example.

This module provides comprehensive validation for the results generated by the
orchestrator, including digit-by-digit analysis and structure validation.
"""

import re
import logging
from typing import List, Dict, Any, Tuple, Optional, Union
from dataclasses import dataclass


@dataclass
class ValidationResult:
    """Container for validation results."""
    is_valid: bool
    errors: List[str]
    warnings: List[str]
    digit_analysis: Dict[str, Any]
    expected_values: Dict[str, Any]
    actual_values: Dict[str, Any]


class ResultValidator:
    """Validates the results from the number pair addition orchestrator."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    def validate_final_concept(self, 
                             concept_name: str,
                             data_tensor: List,
                             axis_names: List[str], 
                             shape: Tuple,
                             input_numbers: Tuple[str, str]) -> ValidationResult:
        """
        Validate the final concept result with comprehensive analysis.
        
        Args:
            concept_name: Name of the concept (e.g., "{new number pair}")
            data_tensor: The nested tensor data structure
            axis_names: List of axis names for the tensor
            shape: Shape of the tensor
            input_numbers: Tuple of input numbers (number_1, number_2)
            
        Returns:
            ValidationResult with detailed analysis
        """
        errors = []
        warnings = []
        digit_analysis = {}
        expected_values = {}
        actual_values = {}
        
        # Basic structure validation
        self._validate_structure(data_tensor, axis_names, shape, errors, warnings)
        
        # Extract and validate the result digits
        if not errors:
            result_digits = self._extract_result_digits(data_tensor, axis_names)
            actual_values['result_digits'] = result_digits
            
            # Calculate expected result
            expected_result = self._calculate_expected_result(input_numbers)
            expected_values['expected_result'] = expected_result
            
            # Build actual result from digits (reverse order)
            actual_result = self._build_result_from_digits(result_digits)
            actual_values['actual_result'] = actual_result
            
            # Digit-by-digit analysis
            digit_analysis = self._analyze_result(result_digits, expected_result, input_numbers)
            
            # Validate the results
            self._validate_result(actual_result, expected_result, errors, warnings)
            
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            digit_analysis=digit_analysis,
            expected_values=expected_values,
            actual_values=actual_values
        )
    
    def _validate_structure(self, data_tensor: List, axis_names: List[str], 
                          shape: Tuple, errors: List[str], warnings: List[str]):
        """Validate the basic structure of the result."""
        
        # Check if data_tensor is a list
        if not isinstance(data_tensor, list):
            errors.append(f"Data tensor should be a list, got {type(data_tensor)}")
            return
            
        # Check if we have the expected number of elements
        if len(data_tensor) != shape[0]:
            errors.append(f"Expected {shape[0]} elements in first dimension, got {len(data_tensor)}")
            
        # Check axis names
        expected_axes = ['number pair', 'get remainder', 'remainder explanation', 'sum', 
                        'get unit place digit', 'unit place digit', 'carry-over number']
        if axis_names != expected_axes:
            warnings.append(f"Axis names differ from expected: {axis_names} vs {expected_axes}")
            
        # Validate tensor depth and structure
        self._validate_tensor_depth(data_tensor, shape, errors)
    
    def _validate_tensor_depth(self, tensor: List, shape: Tuple, errors: List[str], depth: int = 0):
        """Recursively validate tensor depth and structure."""
        if depth >= len(shape):
            # We've reached the deepest level
            if isinstance(tensor, list) and len(tensor) > 0:
                errors.append(f"Tensor is deeper than expected shape {shape}")
            return
            
        if not isinstance(tensor, list):
            errors.append(f"Expected list at depth {depth}, got {type(tensor)}")
            return
            
        if len(tensor) != shape[depth]:
            errors.append(f"Expected {shape[depth]} elements at depth {depth}, got {len(tensor)}")
            
        # Recursively check nested structure
        for i, element in enumerate(tensor):
            if isinstance(element, list):
                self._validate_tensor_depth(element, shape, errors, depth + 1)
    
    def _extract_result_digits(self, data_tensor: List, axis_names: List[str]) -> List[str]:
        """
        Extract result digits from the nested tensor structure.
        
        The final dimension is 'carry-over number' which contains encoded remainder digits.
        Each element represents one digit of the final sum result.
        """
        digits = []
        
        # Navigate through the nested structure to find the carry-over numbers
        # Structure: [[[[[[['%41a(3)']]]]]], [[[[[['%144(9)']]]]]], ...]
        # The deepest level contains encoded strings like '%41a(3)' where (3) is the digit
        
        for element in data_tensor:
            # Navigate to the deepest level where the actual data is stored
            current = element
            while isinstance(current, list) and len(current) == 1:
                current = current[0]
                
            # Extract the digit from the encoded string
            if isinstance(current, str):
                digit = self._extract_encoded_number(current)
                digits.append(digit)
            elif isinstance(current, list) and len(current) > 0:
                # Sometimes there might be nested lists with the encoded value
                digit = self._extract_encoded_number(current[0] if isinstance(current[0], str) else "0")
                digits.append(digit)
            else:
                digits.append("0")
                
        return digits
    
    def _extract_encoded_number(self, encoded_str: str) -> str:
        """Extract the actual number from an encoded string like '%00d(4)'."""
        if not isinstance(encoded_str, str):
            return "0"
            
        # Pattern: '%' followed by hex digits, then '(' followed by decimal digits, then ')'
        match = re.match(r"%([0-9a-f]+)\((\d+)\)", encoded_str)
        if match:
            hex_part = match.group(1)
            decimal_part = match.group(2)
            return decimal_part
        else:
            # Try to extract any number from the string
            numbers = re.findall(r'\d+', encoded_str)
            return numbers[0] if numbers else "0"
    
    def _calculate_expected_result(self, input_numbers: Tuple[str, str]) -> str:
        """Calculate the expected sum result."""
        num1, num2 = input_numbers
        
        # Convert to integers for calculation
        try:
            n1 = int(num1)
            n2 = int(num2)
            result = n1 + n2
            return str(result)
        except ValueError:
            return "0"
    
    def _build_result_from_digits(self, digits: List[str]) -> str:
        """
        Build the final result number from the extracted digits.
        
        The digits are in the order they were processed (rightmost first),
        so we need to reverse them to get the actual result.
        """
        if not digits:
            return "0"
        
        # Reverse the digits to get the correct order
        reversed_digits = digits[::-1]
        
        # Join and remove leading zeros
        result = ''.join(reversed_digits).lstrip('0')
        
        return result if result else "0"
    
    def _analyze_result(self, result_digits: List[str], 
                        expected_result: str,
                        input_numbers: Tuple[str, str]) -> Dict[str, Any]:
        """Perform analysis of the result digits."""
        actual_result = self._build_result_from_digits(result_digits)
        expected_digits = list(expected_result)[::-1]  # Reverse to match processing order
        
        analysis = {
            'input_numbers': input_numbers,
            'expected_sum': expected_result,
            'actual_sum': actual_result,
            'matches': actual_result == expected_result,
            'digit_comparisons': [],
            'errors_by_position': {},
            'summary': {}
        }
        
        # Pad to same length for comparison
        max_len = max(len(result_digits), len(expected_digits))
        padded_actual = result_digits + ['0'] * (max_len - len(result_digits))
        padded_expected = expected_digits + ['0'] * (max_len - len(expected_digits))
        
        # Compare each digit position
        for i in range(max_len):
            actual_digit = padded_actual[i]
            expected_digit = padded_expected[i]
            
            comparison = {
                'position': i,
                'actual': actual_digit,
                'expected': expected_digit,
                'matches': actual_digit == expected_digit
            }
            
            if not comparison['matches']:
                analysis['errors_by_position'][f'digit_{i}'] = {
                    'actual': actual_digit,
                    'expected': expected_digit
                }
            
            analysis['digit_comparisons'].append(comparison)
        
        # Summary statistics
        total_digits = len(analysis['digit_comparisons'])
        matching_digits = sum(1 for comp in analysis['digit_comparisons'] if comp['matches'])
        
        analysis['summary'] = {
            'total_digits': total_digits,
            'matching_digits': matching_digits,
            'accuracy_percentage': (matching_digits / total_digits * 100) if total_digits > 0 else 0,
            'total_errors': len(analysis['errors_by_position'])
        }
        
        return analysis
    
    def _validate_result(self, actual_result: str, 
                        expected_result: str,
                        errors: List[str], warnings: List[str]):
        """Validate that the result is correct."""
        
        if actual_result != expected_result:
            errors.append(f"Result mismatch: actual '{actual_result}' != expected '{expected_result}'")
    
    def validate_from_log_entry(self, log_entry: Dict[str, Any]) -> ValidationResult:
        """
        Validate result from a parsed log entry.
        
        Args:
            log_entry: Dictionary containing:
                - concept_name: str
                - data_tensor: List
                - axis_names: List[str]
                - shape: Tuple
                - input_numbers: Tuple[str, str]
                
        Returns:
            ValidationResult
        """
        return self.validate_final_concept(
            concept_name=log_entry['concept_name'],
            data_tensor=log_entry['data_tensor'],
            axis_names=log_entry['axis_names'],
            shape=log_entry['shape'],
            input_numbers=log_entry['input_numbers']
        )
    
    def print_validation_report(self, result: ValidationResult):
        """Print a detailed validation report."""
        print("\n" + "="*60)
        print("VALIDATION REPORT")
        print("="*60)
        
        print(f"\nOverall Status: {'‚úì VALID' if result.is_valid else '‚úó INVALID'}")
        
        if result.errors:
            print(f"\n‚ùå ERRORS ({len(result.errors)}):")
            for error in result.errors:
                print(f"  - {error}")
        
        if result.warnings:
            print(f"\n‚ö†Ô∏è  WARNINGS ({len(result.warnings)}):")
            for warning in result.warnings:
                print(f"  - {warning}")
        
        # Result analysis
        if result.digit_analysis:
            analysis = result.digit_analysis
            print(f"\nüìä RESULT ANALYSIS:")
            print(f"  - Input Numbers: {analysis['input_numbers']}")
            print(f"  - Expected Sum: {analysis['expected_sum']}")
            print(f"  - Actual Sum: {analysis['actual_sum']}")
            print(f"  - Match: {'‚úì' if analysis['matches'] else '‚úó'}")
            
            if 'summary' in analysis:
                summary = analysis['summary']
                print(f"\nüìê DIGIT-BY-DIGIT BREAKDOWN:")
                print(f"  - Total Digits: {summary['total_digits']}")
                print(f"  - Matching Digits: {summary['matching_digits']}/{summary['total_digits']}")
                print(f"  - Accuracy: {summary['accuracy_percentage']:.1f}%")
                print(f"  - Digit Errors: {summary['total_errors']}")
            
            # Show detailed comparisons only if there are errors
            if not analysis['matches'] and 'digit_comparisons' in analysis:
                print(f"\nüîç DETAILED DIGIT COMPARISONS:")
                for comp in analysis['digit_comparisons']:
                    status = "‚úì" if comp['matches'] else "‚úó"
                    print(f"  {status} Position {comp['position']}: actual={comp['actual']}, expected={comp['expected']}")
        
        print("\n" + "="*60)


def create_test_data():
    """Create test data based on the log example."""
    return {
        'concept_name': '{new number pair}',
        'data_tensor': [
            [[[[[['%00d(4)']]]]]], 
            [[[[[['%7fd(0)']]]]]], 
            [[[[[['%9a8(1)']]]]]]
        ],
        'axis_names': ['number pair', 'get remainder', 'remainder explanation', 'sum', 
                      'get unit place digit', 'unit place digit', 'carry-over number'],
        'shape': (3, 1, 1, 1, 1, 1, 1),
        'input_numbers': ('12', '92')  # Expected sum: 104 (digits: 4, 0, 1 reversed)
    }


if __name__ == "__main__":
    # Test the validator with the example data
    validator = ResultValidator()
    test_data = create_test_data()
    
    print("Testing Result Validator with example data...")
    print(f"Input numbers: {test_data['input_numbers']}")
    print(f"Data tensor: {test_data['data_tensor']}")
    
    result = validator.validate_from_log_entry(test_data)
    validator.print_validation_report(result)
